(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/version.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "version": ()=>version
});
const version = '2.31.0'; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "BaseError": ()=>BaseError,
    "setErrorConfig": ()=>setErrorConfig
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/version.js [app-client] (ecmascript)");
;
let errorConfig = {
    getDocsUrl: (param)=>{
        let { docsBaseUrl, docsPath = '', docsSlug } = param;
        return docsPath ? "".concat(docsBaseUrl !== null && docsBaseUrl !== void 0 ? docsBaseUrl : 'https://viem.sh').concat(docsPath).concat(docsSlug ? "#".concat(docsSlug) : '') : undefined;
    },
    version: "viem@".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"])
};
function setErrorConfig(config) {
    errorConfig = config;
}
class BaseError extends Error {
    walk(fn) {
        return walk(this, fn);
    }
    constructor(shortMessage, args = {}){
        var _errorConfig_getDocsUrl;
        const details = (()=>{
            var _args_cause;
            if (args.cause instanceof BaseError) return args.cause.details;
            if ((_args_cause = args.cause) === null || _args_cause === void 0 ? void 0 : _args_cause.message) return args.cause.message;
            return args.details;
        })();
        const docsPath = (()=>{
            if (args.cause instanceof BaseError) return args.cause.docsPath || args.docsPath;
            return args.docsPath;
        })();
        const docsUrl = (_errorConfig_getDocsUrl = errorConfig.getDocsUrl) === null || _errorConfig_getDocsUrl === void 0 ? void 0 : _errorConfig_getDocsUrl.call(errorConfig, {
            ...args,
            docsPath
        });
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...args.metaMessages ? [
                ...args.metaMessages,
                ''
            ] : [],
            ...docsUrl ? [
                "Docs: ".concat(docsUrl)
            ] : [],
            ...details ? [
                "Details: ".concat(details)
            ] : [],
            ...errorConfig.version ? [
                "Version: ".concat(errorConfig.version)
            ] : []
        ].join('\n');
        super(message, args.cause ? {
            cause: args.cause
        } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        var _args_name;
        this.name = (_args_name = args.name) !== null && _args_name !== void 0 ? _args_name : this.name;
        this.shortMessage = shortMessage;
        this.version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"];
    }
}
function walk(err, fn) {
    if (fn === null || fn === void 0 ? void 0 : fn(err)) return err;
    if (err && typeof err === 'object' && 'cause' in err && err.cause !== undefined) return walk(err.cause, fn);
    return fn ? null : err;
} //# sourceMappingURL=base.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/address.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "InvalidAddressError": ()=>InvalidAddressError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js [app-client] (ecmascript)");
;
class InvalidAddressError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ address }){
        super('Address "'.concat(address, '" is invalid.'), {
            metaMessages: [
                '- Address must be a hex value of 20 bytes (40 hex characters).',
                '- Address must match its checksum counterpart.'
            ],
            name: 'InvalidAddressError'
        });
    }
} //# sourceMappingURL=address.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isHex": ()=>isHex
});
function isHex(value) {
    let { strict = true } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!value) return false;
    if (typeof value !== 'string') return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
} //# sourceMappingURL=isHex.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/data.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "InvalidBytesLengthError": ()=>InvalidBytesLengthError,
    "SizeExceedsPaddingSizeError": ()=>SizeExceedsPaddingSizeError,
    "SliceOffsetOutOfBoundsError": ()=>SliceOffsetOutOfBoundsError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js [app-client] (ecmascript)");
;
class SliceOffsetOutOfBoundsError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ offset, position, size }){
        super("Slice ".concat(position === 'start' ? 'starting' : 'ending', ' at offset "').concat(offset, '" is out-of-bounds (size: ').concat(size, ")."), {
            name: 'SliceOffsetOutOfBoundsError'
        });
    }
}
class SizeExceedsPaddingSizeError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ size, targetSize, type }){
        super("".concat(type.charAt(0).toUpperCase()).concat(type.slice(1).toLowerCase(), " size (").concat(size, ") exceeds padding size (").concat(targetSize, ")."), {
            name: 'SizeExceedsPaddingSizeError'
        });
    }
}
class InvalidBytesLengthError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ size, targetSize, type }){
        super("".concat(type.charAt(0).toUpperCase()).concat(type.slice(1).toLowerCase(), " is expected to be ").concat(targetSize, " ").concat(type, " long, but is ").concat(size, " ").concat(type, " long."), {
            name: 'InvalidBytesLengthError'
        });
    }
} //# sourceMappingURL=data.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "pad": ()=>pad,
    "padBytes": ()=>padBytes,
    "padHex": ()=>padHex
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/data.js [app-client] (ecmascript)");
;
function pad(hexOrBytes) {
    let { dir, size = 32 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof hexOrBytes === 'string') return padHex(hexOrBytes, {
        dir,
        size
    });
    return padBytes(hexOrBytes, {
        dir,
        size
    });
}
function padHex(hex_) {
    let { dir, size = 32 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (size === null) return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SizeExceedsPaddingSizeError"]({
        size: Math.ceil(hex.length / 2),
        targetSize: size,
        type: 'hex'
    });
    return "0x".concat(hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0'));
}
function padBytes(bytes) {
    let { dir, size = 32 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (size === null) return bytes;
    if (bytes.length > size) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SizeExceedsPaddingSizeError"]({
        size: bytes.length,
        targetSize: size,
        type: 'bytes'
    });
    const paddedBytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
} //# sourceMappingURL=pad.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "IntegerOutOfRangeError": ()=>IntegerOutOfRangeError,
    "InvalidBytesBooleanError": ()=>InvalidBytesBooleanError,
    "InvalidHexBooleanError": ()=>InvalidHexBooleanError,
    "InvalidHexValueError": ()=>InvalidHexValueError,
    "SizeOverflowError": ()=>SizeOverflowError
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js [app-client] (ecmascript)");
;
class IntegerOutOfRangeError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ max, min, signed, size, value }){
        super('Number "'.concat(value, '" is not in safe ').concat(size ? "".concat(size * 8, "-bit ").concat(signed ? 'signed' : 'unsigned', " ") : '', "integer range ").concat(max ? "(".concat(min, " to ").concat(max, ")") : "(above ".concat(min, ")")), {
            name: 'IntegerOutOfRangeError'
        });
    }
}
class InvalidBytesBooleanError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor(bytes){
        super('Bytes value "'.concat(bytes, '" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.'), {
            name: 'InvalidBytesBooleanError'
        });
    }
}
class InvalidHexBooleanError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor(hex){
        super('Hex value "'.concat(hex, '" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).'), {
            name: 'InvalidHexBooleanError'
        });
    }
}
class InvalidHexValueError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor(value){
        super('Hex value "'.concat(value, '" is an odd length (').concat(value.length, "). It must be an even length."), {
            name: 'InvalidHexValueError'
        });
    }
}
class SizeOverflowError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ givenSize, maxSize }){
        super("Size cannot exceed ".concat(maxSize, " bytes. Given size: ").concat(givenSize, " bytes."), {
            name: 'SizeOverflowError'
        });
    }
} //# sourceMappingURL=encoding.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "size": ()=>size
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js [app-client] (ecmascript)");
;
function size(value) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHex"])(value, {
        strict: false
    })) return Math.ceil((value.length - 2) / 2);
    return value.length;
} //# sourceMappingURL=size.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/trim.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "trim": ()=>trim
});
function trim(hexOrBytes) {
    let { dir = 'left' } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
    let sliceLength = 0;
    for(let i = 0; i < data.length - 1; i++){
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;
        else break;
    }
    data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === 'string') {
        if (data.length === 1 && dir === 'right') data = "".concat(data, "0");
        return "0x".concat(data.length % 2 === 1 ? "0".concat(data) : data);
    }
    return data;
} //# sourceMappingURL=trim.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "assertSize": ()=>assertSize,
    "fromHex": ()=>fromHex,
    "hexToBigInt": ()=>hexToBigInt,
    "hexToBool": ()=>hexToBool,
    "hexToNumber": ()=>hexToNumber,
    "hexToString": ()=>hexToString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/trim.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js [app-client] (ecmascript)");
;
;
;
;
function assertSize(hexOrBytes, param) {
    let { size } = param;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"])(hexOrBytes) > size) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SizeOverflowError"]({
        givenSize: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"])(hexOrBytes),
        maxSize: size
    });
}
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? {
        to: toOrOpts
    } : toOrOpts;
    const to = opts.to;
    if (to === 'number') return hexToNumber(hex, opts);
    if (to === 'bigint') return hexToBigInt(hex, opts);
    if (to === 'string') return hexToString(hex, opts);
    if (to === 'boolean') return hexToBool(hex, opts);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToBytes"])(hex, opts);
}
function hexToBigInt(hex) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { signed } = opts;
    if (opts.size) assertSize(hex, {
        size: opts.size
    });
    const value = BigInt(hex);
    if (!signed) return value;
    const size = (hex.length - 2) / 2;
    const max = (1n << BigInt(size) * 8n - 1n) - 1n;
    if (value <= max) return value;
    return value - BigInt("0x".concat('f'.padStart(size * 2, 'f'))) - 1n;
}
function hexToBool(hex_) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, {
            size: opts.size
        });
        hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(hex);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(hex) === '0x00') return false;
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(hex) === '0x01') return true;
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidHexBooleanError"](hex);
}
function hexToNumber(hex) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Number(hexToBigInt(hex, opts));
}
function hexToString(hex) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToBytes"])(hex);
    if (opts.size) {
        assertSize(bytes, {
            size: opts.size
        });
        bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(bytes, {
            dir: 'right'
        });
    }
    return new TextDecoder().decode(bytes);
} //# sourceMappingURL=fromHex.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "boolToHex": ()=>boolToHex,
    "bytesToHex": ()=>bytesToHex,
    "numberToHex": ()=>numberToHex,
    "stringToHex": ()=>stringToHex,
    "toHex": ()=>toHex
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/encoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js [app-client] (ecmascript)");
;
;
;
const hexes = /*#__PURE__*/ Array.from({
    length: 256
}, (_v, i)=>i.toString(16).padStart(2, '0'));
function toHex(value) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);
    if (typeof value === 'string') {
        return stringToHex(value, opts);
    }
    if (typeof value === 'boolean') return boolToHex(value, opts);
    return bytesToHex(value, opts);
}
function boolToHex(value) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const hex = "0x".concat(Number(value));
    if (typeof opts.size === 'number') {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(hex, {
            size: opts.size
        });
    }
    return hex;
}
function bytesToHex(value) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let string = '';
    for(let i = 0; i < value.length; i++){
        string += hexes[value[i]];
    }
    const hex = "0x".concat(string);
    if (typeof opts.size === 'number') {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(hex, {
            dir: 'right',
            size: opts.size
        });
    }
    return hex;
}
function numberToHex(value_) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        else maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    } else if (typeof value_ === 'number') {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === 'bigint' ? 'n' : '';
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IntegerOutOfRangeError"]({
            max: maxValue ? "".concat(maxValue).concat(suffix) : undefined,
            min: "".concat(minValue).concat(suffix),
            signed,
            size,
            value: "".concat(value_).concat(suffix)
        });
    }
    const hex = "0x".concat((signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16));
    if (size) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(hex, {
        size
    });
    return hex;
}
const encoder = /*#__PURE__*/ new TextEncoder();
function stringToHex(value_) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
} //# sourceMappingURL=toHex.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "boolToBytes": ()=>boolToBytes,
    "hexToBytes": ()=>hexToBytes,
    "numberToBytes": ()=>numberToBytes,
    "stringToBytes": ()=>stringToBytes,
    "toBytes": ()=>toBytes
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/pad.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js [app-client] (ecmascript)");
;
;
;
;
;
const encoder = /*#__PURE__*/ new TextEncoder();
function toBytes(value) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (typeof value === 'number' || typeof value === 'bigint') return numberToBytes(value, opts);
    if (typeof value === 'boolean') return boolToBytes(value, opts);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHex"])(value)) return hexToBytes(value, opts);
    return stringToBytes(value, opts);
}
function boolToBytes(value) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === 'number') {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertSize"])(bytes, {
            size: opts.size
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(bytes, {
            size: opts.size
        });
    }
    return bytes;
}
// We use very optimized technique to convert hex string to byte array
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);
    return undefined;
}
function hexToBytes(hex_) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let hex = hex_;
    if (opts.size) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(hex, {
            dir: 'right',
            size: opts.size
        });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2) hexString = "0".concat(hexString);
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for(let index = 0, j = 0; index < length; index++){
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BaseError"]('Invalid byte sequence ("'.concat(hexString[j - 2]).concat(hexString[j - 1], '" in "').concat(hexString, '").'));
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
function numberToBytes(value, opts) {
    const hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberToHex"])(value, opts);
    return hexToBytes(hex);
}
function stringToBytes(value) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const bytes = encoder.encode(value);
    if (typeof opts.size === 'number') {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertSize"])(bytes, {
            size: opts.size
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$pad$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(bytes, {
            dir: 'right',
            size: opts.size
        });
    }
    return bytes;
} //# sourceMappingURL=toBytes.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_u64.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ __turbopack_context__.s({
    "add": ()=>add,
    "add3H": ()=>add3H,
    "add3L": ()=>add3L,
    "add4H": ()=>add4H,
    "add4L": ()=>add4L,
    "add5H": ()=>add5H,
    "add5L": ()=>add5L,
    "default": ()=>__TURBOPACK__default__export__,
    "fromBig": ()=>fromBig,
    "rotlBH": ()=>rotlBH,
    "rotlBL": ()=>rotlBL,
    "rotlSH": ()=>rotlSH,
    "rotlSL": ()=>rotlSL,
    "rotr32H": ()=>rotr32H,
    "rotr32L": ()=>rotr32L,
    "rotrBH": ()=>rotrBH,
    "rotrBL": ()=>rotrBL,
    "rotrSH": ()=>rotrSH,
    "rotrSL": ()=>rotrSL,
    "shrSH": ()=>shrSH,
    "shrSL": ()=>shrSL,
    "split": ()=>split,
    "toBig": ()=>toBig
});
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n) {
    let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst) {
    let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
const rotr32L = (h, _l)=>h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
const __TURBOPACK__default__export__ = u64;
 //# sourceMappingURL=_u64.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "crypto": ()=>crypto
});
const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined; //# sourceMappingURL=crypto.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
__turbopack_context__.s({
    "Hash": ()=>Hash,
    "abytes": ()=>abytes,
    "aexists": ()=>aexists,
    "ahash": ()=>ahash,
    "anumber": ()=>anumber,
    "aoutput": ()=>aoutput,
    "asyncLoop": ()=>asyncLoop,
    "byteSwap": ()=>byteSwap,
    "byteSwap32": ()=>byteSwap32,
    "byteSwapIfBE": ()=>byteSwapIfBE,
    "bytesToHex": ()=>bytesToHex,
    "bytesToUtf8": ()=>bytesToUtf8,
    "checkOpts": ()=>checkOpts,
    "clean": ()=>clean,
    "concatBytes": ()=>concatBytes,
    "createHasher": ()=>createHasher,
    "createOptHasher": ()=>createOptHasher,
    "createView": ()=>createView,
    "createXOFer": ()=>createXOFer,
    "hexToBytes": ()=>hexToBytes,
    "isBytes": ()=>isBytes,
    "isLE": ()=>isLE,
    "kdfInputToBytes": ()=>kdfInputToBytes,
    "nextTick": ()=>nextTick,
    "randomBytes": ()=>randomBytes,
    "rotl": ()=>rotl,
    "rotr": ()=>rotr,
    "swap32IfBE": ()=>swap32IfBE,
    "swap8IfBE": ()=>swap8IfBE,
    "toBytes": ()=>toBytes,
    "u32": ()=>u32,
    "u8": ()=>u8,
    "utf8ToBytes": ()=>utf8ToBytes,
    "wrapConstructor": ()=>wrapConstructor,
    "wrapConstructorWithOpts": ()=>wrapConstructorWithOpts,
    "wrapXOFConstructorWithOpts": ()=>wrapXOFConstructorWithOpts
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)");
;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
function abytes(b) {
    for(var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        lengths[_key - 1] = arguments[_key];
    }
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
function aexists(instance) {
    let checkFinished = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean() {
    for(var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++){
        arrays[_key] = arguments[_key];
    }
    for(let i = 0; i < arrays.length; i++){
        arrays[i].fill(0);
    }
}
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
const swap8IfBE = isLE ? (n)=>n : (n)=>byteSwap(n);
const byteSwapIfBE = swap8IfBE;
function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++){
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
const swap32IfBE = isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
function concatBytes() {
    for(var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++){
        arrays[_key] = arguments[_key];
    }
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
class Hash {
}
function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
const wrapConstructor = createHasher;
const wrapConstructorWithOpts = createOptHasher;
const wrapXOFConstructorWithOpts = createXOFer;
function randomBytes() {
    let bytesLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues === 'function') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].randomBytes === 'function') {
        return Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha3.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */ __turbopack_context__.s({
    "Keccak": ()=>Keccak,
    "keccakP": ()=>keccakP,
    "keccak_224": ()=>keccak_224,
    "keccak_256": ()=>keccak_256,
    "keccak_384": ()=>keccak_384,
    "keccak_512": ()=>keccak_512,
    "sha3_224": ()=>sha3_224,
    "sha3_256": ()=>sha3_256,
    "sha3_384": ()=>sha3_384,
    "sha3_512": ()=>sha3_512,
    "shake128": ()=>shake128,
    "shake256": ()=>shake256
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/_u64.js [app-client] (ecmascript)");
// prettier-ignore
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
;
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["split"])(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlBH"])(h, l, s) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlSH"])(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlBL"])(h, l, s) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlSL"])(h, l, s);
function keccakP(s) {
    let rounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 24;
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta 
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(B);
}
class Keccak extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hash"] {
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["swap32IfBE"])(this.state32);
        keccakP(this.state32, this.rounds);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["swap32IfBE"])(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this);
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBytes"])(data);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(data);
        const { blockLen, state } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this, false);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["anumber"])(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aoutput"])(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["anumber"])(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200)) throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u32"])(this.state);
    }
}
const gen = (suffix, blockLen, outputLen)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHasher"])(()=>new Keccak(blockLen, suffix, outputLen));
const sha3_224 = /* @__PURE__ */ (()=>gen(0x06, 144, 224 / 8))();
const sha3_256 = /* @__PURE__ */ (()=>gen(0x06, 136, 256 / 8))();
const sha3_384 = /* @__PURE__ */ (()=>gen(0x06, 104, 384 / 8))();
const sha3_512 = /* @__PURE__ */ (()=>gen(0x06, 72, 512 / 8))();
const keccak_224 = /* @__PURE__ */ (()=>gen(0x01, 144, 224 / 8))();
const keccak_256 = /* @__PURE__ */ (()=>gen(0x01, 136, 256 / 8))();
const keccak_384 = /* @__PURE__ */ (()=>gen(0x01, 104, 384 / 8))();
const keccak_512 = /* @__PURE__ */ (()=>gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createXOFer"])(function() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);
    });
const shake128 = /* @__PURE__ */ (()=>genShake(0x1f, 168, 128 / 8))();
const shake256 = /* @__PURE__ */ (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "keccak256": ()=>keccak256
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/sha3.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js [app-client] (ecmascript)");
;
;
;
;
function keccak256(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keccak_256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHex"])(value, {
        strict: false
    }) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBytes"])(value) : value);
    if (to === 'bytes') return bytes;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(bytes);
} //# sourceMappingURL=keccak256.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

/**
 * Map with a LRU (Least recently used) policy.
 *
 * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
 */ __turbopack_context__.s({
    "LruMap": ()=>LruMap
});
class LruMap extends Map {
    get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== undefined) {
            this.delete(key);
            super.set(key, value);
        }
        return value;
    }
    set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey) this.delete(firstKey);
        }
        return this;
    }
    constructor(size){
        super();
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxSize = size;
    }
} //# sourceMappingURL=lru.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/isAddress.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "isAddress": ()=>isAddress,
    "isAddressCache": ()=>isAddressCache
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$lru$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js [app-client] (ecmascript)");
;
;
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
const isAddressCache = /*#__PURE__*/ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$lru$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LruMap"](8192);
function isAddress(address, options) {
    const { strict = true } = options !== null && options !== void 0 ? options : {};
    const cacheKey = "".concat(address, ".").concat(strict);
    if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey);
    const result = (()=>{
        if (!addressRegex.test(address)) return false;
        if (address.toLowerCase() === address) return true;
        if (strict) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checksumAddress"])(address) === address;
        return true;
    })();
    isAddressCache.set(cacheKey, result);
    return result;
} //# sourceMappingURL=isAddress.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "checksumAddress": ()=>checksumAddress,
    "getAddress": ()=>getAddress
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$address$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/errors/address.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toBytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$lru$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/lru.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/isAddress.js [app-client] (ecmascript)");
;
;
;
;
;
const checksumAddressCache = /*#__PURE__*/ new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$lru$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LruMap"](8192);
function checksumAddress(address_, /**
 * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
 * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
 * that relies on EIP-55 checksum encoding (checksum without chainId).
 *
 * It is highly recommended to not use this feature unless you
 * know what you are doing.
 *
 * See more: https://github.com/ethereum/EIPs/issues/1121
 */ chainId) {
    if (checksumAddressCache.has("".concat(address_, ".").concat(chainId))) return checksumAddressCache.get("".concat(address_, ".").concat(chainId));
    const hexAddress = chainId ? "".concat(chainId).concat(address_.toLowerCase()) : address_.substring(2).toLowerCase();
    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toBytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringToBytes"])(hexAddress), 'bytes');
    const address = (chainId ? hexAddress.substring("".concat(chainId, "0x").length) : hexAddress).split('');
    for(let i = 0; i < 40; i += 2){
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
            address[i] = address[i].toUpperCase();
        }
        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
            address[i + 1] = address[i + 1].toUpperCase();
        }
    }
    const result = "0x".concat(address.join(''));
    checksumAddressCache.set("".concat(address_, ".").concat(chainId), result);
    return result;
}
function getAddress(address, /**
 * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
 * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
 * that relies on EIP-55 checksum encoding (checksum without chainId).
 *
 * It is highly recommended to not use this feature unless you
 * know what you are doing.
 *
 * See more: https://github.com/ethereum/EIPs/issues/1121
 */ chainId) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAddress"])(address, {
        strict: false
    })) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$address$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidAddressError"]({
        address
    });
    return checksumAddress(address, chainId);
} //# sourceMappingURL=getAddress.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "publicKeyToAddress": ()=>publicKeyToAddress
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/address/getAddress.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/hash/keccak256.js [app-client] (ecmascript)");
;
;
function publicKeyToAddress(publicKey) {
    const address = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$keccak256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keccak256"])("0x".concat(publicKey.substring(4))).substring(26);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checksumAddress"])("0x".concat(address));
} //# sourceMappingURL=publicKeyToAddress.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "recoverPublicKey": ()=>recoverPublicKey
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/isHex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/data/size.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/fromHex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/encoding/toHex.js [app-client] (ecmascript)");
;
;
;
;
async function recoverPublicKey(param) {
    let { hash, signature } = param;
    const hashHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHex"])(hash) ? hash : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(hash);
    const { secp256k1 } = await __turbopack_context__.r("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/node_modules/@noble/curves/esm/secp256k1.js [app-client] (ecmascript, async loader)")(__turbopack_context__.i);
    const signature_ = (()=>{
        // typeof signature: `Signature`
        if (typeof signature === 'object' && 'r' in signature && 's' in signature) {
            const { r, s, v, yParity } = signature;
            const yParityOrV = Number(yParity !== null && yParity !== void 0 ? yParity : v);
            const recoveryBit = toRecoveryBit(yParityOrV);
            return new secp256k1.Signature((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToBigInt"])(r), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToBigInt"])(s)).addRecoveryBit(recoveryBit);
        }
        // typeof signature: `Hex | ByteArray`
        const signatureHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$isHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHex"])(signature) ? signature : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(signature);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"])(signatureHex) !== 65) throw new Error('invalid signature length');
        const yParityOrV = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToNumber"])("0x".concat(signatureHex.slice(130)));
        const recoveryBit = toRecoveryBit(yParityOrV);
        return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
    })();
    const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
    return "0x".concat(publicKey);
}
function toRecoveryBit(yParityOrV) {
    if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;
    if (yParityOrV === 27) return 0;
    if (yParityOrV === 28) return 1;
    throw new Error('Invalid yParityOrV value');
} //# sourceMappingURL=recoverPublicKey.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "recoverAddress": ()=>recoverAddress
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$utils$2f$publicKeyToAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$signature$2f$recoverPublicKey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js [app-client] (ecmascript)");
;
;
async function recoverAddress(param) {
    let { hash, signature } = param;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$utils$2f$publicKeyToAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["publicKeyToAddress"])(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$signature$2f$recoverPublicKey$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["recoverPublicKey"])({
        hash,
        signature
    }));
} //# sourceMappingURL=recoverAddress.js.map
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "compare": ()=>compare
});
function compare(a, b) {
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) {
            return -1;
        }
        if (a[i] > b[i]) {
            return 1;
        }
    }
    if (a.byteLength > b.byteLength) {
        return 1;
    }
    if (a.byteLength < b.byteLength) {
        return -1;
    }
    return 0;
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "asUint8Array": ()=>asUint8Array
});
function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "alloc": ()=>alloc,
    "allocUnsafe": ()=>allocUnsafe
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
function alloc() {
    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.alloc(size));
    }
    return new Uint8Array(size);
}
function allocUnsafe() {
    let size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "concat": ()=>concat
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (!length) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "equals": ()=>equals
});
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)");
;
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "fromString": ()=>fromString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function fromString(string) {
    let encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'utf8';
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (!base) {
        throw new Error('Unsupported encoding "'.concat(encoding, '"'));
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.from(string, 'utf-8'));
    }
    return base.decoder.decode("".concat(base.prefix).concat(string));
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "toString": ()=>toString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)");
;
function toString(array) {
    let encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'utf8';
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (!base) {
        throw new Error('Unsupported encoding "'.concat(encoding, '"'));
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }
    return base.encoder.encode(array).substring(1);
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "xor": ()=>xor
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function xor(a, b) {
    if (a.length !== b.length) {
        throw new Error('Inputs should have the same length');
    }
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(a.length);
    for(let i = 0; i < a.length; i++){
        result[i] = a[i] ^ b[i];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(result);
}
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
}),
"[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <locals>");
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "BASE10": ()=>$n,
    "BASE16": ()=>tt,
    "BASE64": ()=>Qt,
    "BASE64URL": ()=>De,
    "COLON": ()=>Hs,
    "DEFAULT_DEPTH": ()=>We,
    "EMPTY_SPACE": ()=>Ee,
    "ENV_MAP": ()=>J,
    "INTERNAL_ERRORS": ()=>Qo,
    "LimitedSet": ()=>gi,
    "MemoryStore": ()=>Ha,
    "ONE_THOUSAND": ()=>Ds,
    "REACT_NATIVE_PRODUCT": ()=>er,
    "RELAYER_DEFAULT_PROTOCOL": ()=>Mo,
    "SDK_ERRORS": ()=>Jo,
    "SDK_TYPE": ()=>rr,
    "SLASH": ()=>nr,
    "TYPE_0": ()=>Cn,
    "TYPE_1": ()=>ee,
    "TYPE_2": ()=>ge,
    "UTF8": ()=>te,
    "addResourceToRecap": ()=>Yr,
    "addSignatureToExtrinsic": ()=>bs,
    "appendToQueryString": ()=>or,
    "assertType": ()=>Zs,
    "assignAbilityToActions": ()=>hn,
    "base64Decode": ()=>Zr,
    "base64Encode": ()=>Gr,
    "buildApprovedNamespaces": ()=>pa,
    "buildAuthObject": ()=>mf,
    "buildNamespacesFromAuth": ()=>ga,
    "buildRecapStatement": ()=>Jr,
    "buildSignedExtrinsicHash": ()=>Ka,
    "calcExpiry": ()=>ii,
    "capitalize": ()=>ti,
    "capitalizeWord": ()=>lr,
    "createDelayedPromise": ()=>ei,
    "createEncodedRecap": ()=>Ef,
    "createExpiringPromise": ()=>ni,
    "createRecap": ()=>Wr,
    "decodeRecap": ()=>Lt,
    "decodeTypeByte": ()=>Vt,
    "decodeTypeTwoEnvelope": ()=>Yc,
    "decrypt": ()=>Zc,
    "deriveExtrinsicHash": ()=>ys,
    "deriveSymKey": ()=>Kc,
    "deserialize": ()=>Me,
    "encodeRecap": ()=>Ne,
    "encodeTypeByte": ()=>jn,
    "encodeTypeTwoEnvelope": ()=>Wc,
    "encrypt": ()=>Gc,
    "engineEvent": ()=>ci,
    "enumify": ()=>Qs,
    "extractSolanaTransactionId": ()=>sf,
    "formatAccountId": ()=>Zn,
    "formatAccountWithChain": ()=>Os,
    "formatChainId": ()=>Gn,
    "formatDeeplinkUrl": ()=>dr,
    "formatExpirerTarget": ()=>Xe,
    "formatIdTarget": ()=>oi,
    "formatMessage": ()=>qr,
    "formatMessageContext": ()=>Ws,
    "formatRelayParams": ()=>Ko,
    "formatRelayRpcUrl": ()=>zs,
    "formatStatementFromRecap": ()=>gn,
    "formatTopicTarget": ()=>ri,
    "formatUA": ()=>cr,
    "formatUri": ()=>oa,
    "fromBase64": ()=>Qe,
    "generateKeyPair": ()=>Vc,
    "generateRandomBytes32": ()=>qc,
    "getAccountsChains": ()=>qt,
    "getAccountsFromNamespaces": ()=>_s,
    "getAddressFromAccount": ()=>Wn,
    "getAddressesFromAccounts": ()=>Us,
    "getAlgorandTransactionId": ()=>af,
    "getAppId": ()=>qs,
    "getAppMetadata": ()=>sr,
    "getBrowserOnlineStatus": ()=>us,
    "getChainFromAccount": ()=>Yn,
    "getChainsFromAccounts": ()=>Xn,
    "getChainsFromNamespace": ()=>ve,
    "getChainsFromNamespaces": ()=>Ts,
    "getChainsFromRecap": ()=>Af,
    "getChainsFromRequiredNamespaces": ()=>Rs,
    "getCommonValuesInArrays": ()=>Je,
    "getCryptoKeyFromKeyData": ()=>Do,
    "getDecodedRecapFromResources": ()=>Kr,
    "getDeepLink": ()=>ui,
    "getDidAddress": ()=>dn,
    "getDidAddressSegments": ()=>Se,
    "getDidChainId": ()=>Mr,
    "getEnvironment": ()=>Pt,
    "getHttpUrl": ()=>Gs,
    "getInternalError": ()=>Et,
    "getJavascriptID": ()=>fr,
    "getJavascriptOS": ()=>ir,
    "getLastItems": ()=>ur,
    "getLinkModeURL": ()=>sa,
    "getMethodsFromRecap": ()=>If,
    "getNamespacedDidChainId": ()=>Vr,
    "getNamespacesChains": ()=>Go,
    "getNamespacesEventsForChainId": ()=>Wo,
    "getNamespacesFromAccounts": ()=>Xo,
    "getNamespacesMethodsForChainId": ()=>Zo,
    "getNearTransactionIdFromSignedTransaction": ()=>cf,
    "getNearUint8ArrayFromBytes": ()=>kr,
    "getNodeOnlineStatus": ()=>ds,
    "getReCapActions": ()=>zr,
    "getReactNativeOnlineStatus": ()=>ls,
    "getRecapAbilitiesFromResource": ()=>vf,
    "getRecapFromResources": ()=>Oe,
    "getRecapResource": ()=>Fr,
    "getRelayClientMetadata": ()=>Fs,
    "getRelayProtocolApi": ()=>na,
    "getRelayProtocolName": ()=>ea,
    "getRequiredNamespacesFromNamespaces": ()=>ha,
    "getSdkError": ()=>Kt,
    "getSearchParamFromURL": ()=>li,
    "getSignDirectHash": ()=>uf,
    "getSuiDigest": ()=>ff,
    "getUniqueValues": ()=>Ge,
    "handleDeeplinkRedirect": ()=>ai,
    "hasOverlap": ()=>It,
    "hashEthereumMessage": ()=>an,
    "hashKey": ()=>Fc,
    "hashMessage": ()=>zc,
    "isAndroid": ()=>Ms,
    "isAppVisible": ()=>Pa,
    "isBrowser": ()=>zt,
    "isCaipNamespace": ()=>Pn,
    "isConformingNamespaces": ()=>cs,
    "isExpired": ()=>fi,
    "isIframe": ()=>gr,
    "isIos": ()=>Vs,
    "isNode": ()=>Ye,
    "isOnline": ()=>ja,
    "isProposalStruct": ()=>wa,
    "isReactNative": ()=>Bt,
    "isRecap": ()=>pn,
    "isSessionCompatible": ()=>ya,
    "isSessionStruct": ()=>xa,
    "isTelegram": ()=>pr,
    "isTestRun": ()=>hi,
    "isTypeOneEnvelope": ()=>Jc,
    "isTypeTwoEnvelope": ()=>Qc,
    "isUndefined": ()=>kt,
    "isValidAccountId": ()=>ts,
    "isValidAccounts": ()=>rs,
    "isValidActions": ()=>ss,
    "isValidArray": ()=>me,
    "isValidChainId": ()=>we,
    "isValidChains": ()=>es,
    "isValidController": ()=>va,
    "isValidEip1271Signature": ()=>jr,
    "isValidEip191Signature": ()=>Lr,
    "isValidErrorReason": ()=>Sa,
    "isValidEvent": ()=>Ua,
    "isValidId": ()=>Ia,
    "isValidNamespaceAccounts": ()=>os,
    "isValidNamespaceActions": ()=>Dn,
    "isValidNamespaceChains": ()=>ns,
    "isValidNamespaceMethodsOrEvents": ()=>Hn,
    "isValidNamespaces": ()=>is,
    "isValidNamespacesChainId": ()=>_a,
    "isValidNamespacesEvent": ()=>Ra,
    "isValidNamespacesRequest": ()=>Ta,
    "isValidNumber": ()=>qe,
    "isValidObject": ()=>Ve,
    "isValidParams": ()=>Aa,
    "isValidRecap": ()=>bt,
    "isValidRelay": ()=>fs,
    "isValidRelays": ()=>Ba,
    "isValidRequest": ()=>Na,
    "isValidRequestExpiry": ()=>La,
    "isValidRequiredNamespaces": ()=>Ea,
    "isValidResponse": ()=>Oa,
    "isValidString": ()=>it,
    "isValidUrl": ()=>ma,
    "mapEntries": ()=>Js,
    "mapToObj": ()=>Ys,
    "mergeArrays": ()=>ct,
    "mergeEncodedRecaps": ()=>Bf,
    "mergeRecaps": ()=>Xr,
    "mergeRequiredAndOptionalNamespaces": ()=>ba,
    "normalizeNamespaces": ()=>ye,
    "objToMap": ()=>Xs,
    "openDeeplink": ()=>hr,
    "parseAccountId": ()=>ze,
    "parseChainId": ()=>Fe,
    "parseContextNames": ()=>ar,
    "parseExpirerTarget": ()=>si,
    "parseNamespaceKey": ()=>Yo,
    "parseRelayParams": ()=>Vo,
    "parseTopic": ()=>qo,
    "parseUri": ()=>ra,
    "populateAppMetadata": ()=>Ks,
    "populateAuthPayload": ()=>wf,
    "recapHasResource": ()=>xf,
    "serialize": ()=>kn,
    "sleep": ()=>pi,
    "ss58AddressToPublicKey": ()=>gs,
    "subscribeToBrowserNetworkChange": ()=>hs,
    "subscribeToNetworkChange": ()=>ka,
    "subscribeToReactNativeNetworkChange": ()=>ps,
    "toBase64": ()=>br,
    "uuidv4": ()=>di,
    "validateDecoding": ()=>Xc,
    "validateEncoding": ()=>Ho,
    "validateSignedCacao": ()=>yf,
    "verifyP256Jwt": ()=>ta,
    "verifySignature": ()=>Cr
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$detect$2d$browser$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/detect-browser/es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$time$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/time/dist/cjs/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/window-getters/dist/cjs/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$metadata$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/window-metadata/dist/cjs/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$signature$2f$recoverAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bs58/src/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$esm$2f$decode$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.esm/decode.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$esm$2f$encode$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.esm/encode.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/base/lib/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$relay$2d$auth$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/relay-auth/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$relay$2d$api$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/relay-api/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blakejs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/blakejs/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
const xe = ":";
function Fe(t) {
    const [e, n] = t.split(xe);
    return {
        namespace: e,
        reference: n
    };
}
function Gn(t) {
    const { namespace: e, reference: n } = t;
    return [
        e,
        n
    ].join(xe);
}
function ze(t) {
    const [e, n, r] = t.split(xe);
    return {
        namespace: e,
        reference: n,
        address: r
    };
}
function Zn(t) {
    const { namespace: e, reference: n, address: r } = t;
    return [
        e,
        n,
        r
    ].join(xe);
}
function Ge(t, e) {
    const n = [];
    return t.forEach((r)=>{
        const o = e(r);
        n.includes(o) || n.push(o);
    }), n;
}
function Wn(t) {
    const { address: e } = ze(t);
    return e;
}
function Yn(t) {
    const { namespace: e, reference: n } = ze(t);
    return Gn({
        namespace: e,
        reference: n
    });
}
function Os(t, e) {
    const { namespace: n, reference: r } = Fe(e);
    return Zn({
        namespace: n,
        reference: r,
        address: t
    });
}
function Us(t) {
    return Ge(t, Wn);
}
function Xn(t) {
    return Ge(t, Yn);
}
function _s(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const n = [];
    return Object.keys(t).forEach((r)=>{
        if (e.length && !e.includes(r)) return;
        const o = t[r];
        n.push(...o.accounts);
    }), n;
}
function Ts(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const n = [];
    return Object.keys(t).forEach((r)=>{
        if (e.length && !e.includes(r)) return;
        const o = t[r];
        n.push(...Xn(o.accounts));
    }), n;
}
function Rs(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const n = [];
    return Object.keys(t).forEach((r)=>{
        if (e.length && !e.includes(r)) return;
        const o = t[r];
        n.push(...ve(r, o));
    }), n;
}
function ve(t, e) {
    return t.includes(":") ? [
        t
    ] : e.chains || [];
}
var $s = Object.defineProperty, Cs = Object.defineProperties, Ls = Object.getOwnPropertyDescriptors, Jn = Object.getOwnPropertySymbols, js = Object.prototype.hasOwnProperty, ks = Object.prototype.propertyIsEnumerable, Ze = (t, e, n)=>e in t ? $s(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n, Qn = (t, e)=>{
    for(var n in e || (e = {}))js.call(e, n) && Ze(t, n, e[n]);
    if (Jn) for (var n of Jn(e))ks.call(e, n) && Ze(t, n, e[n]);
    return t;
}, Ps = (t, e)=>Cs(t, Ls(e)), tr = (t, e, n)=>Ze(t, typeof e != "symbol" ? e + "" : e, n);
const er = "ReactNative", J = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
}, Ee = " ", Hs = ":", nr = "/", We = 2, Ds = 1e3, rr = "js";
function Ye() {
    return typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] < "u" && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions < "u" && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node < "u";
}
function Bt() {
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])() && !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNavigator"])() && navigator.product === er;
}
function Ms() {
    return Bt() && ("TURBOPACK compile-time value", "object") < "u" && typeof (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).Platform) < "u" && (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).Platform.OS) === "android";
}
function Vs() {
    return Bt() && ("TURBOPACK compile-time value", "object") < "u" && typeof (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).Platform) < "u" && (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).Platform.OS) === "ios";
}
function zt() {
    return !Ye() && !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNavigator"])() && !!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])();
}
function Pt() {
    return Bt() ? J.reactNative : Ye() ? J.node : zt() ? J.browser : J.unknown;
}
function qs() {
    var t;
    try {
        return Bt() && ("TURBOPACK compile-time value", "object") < "u" && typeof (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).Application) < "u" ? (t = ("TURBOPACK ident replacement", globalThis).Application) == null ? void 0 : t.applicationId : void 0;
    } catch (e) {
        return;
    }
}
function or(t, e) {
    const n = new URLSearchParams(t);
    for (const r of Object.keys(e).sort())if (e.hasOwnProperty(r)) {
        const o = e[r];
        o !== void 0 && n.set(r, o);
    }
    return n.toString();
}
function Ks(t) {
    var e, n;
    const r = sr();
    try {
        return t != null && t.url && r.url && new URL(t.url).host !== new URL(r.url).host && (console.warn("The configured WalletConnect 'metadata.url':".concat(t.url, " differs from the actual page url:").concat(r.url, ". This is probably unintended and can lead to issues.")), t.url = r.url), (e = t === null || t === void 0 ? void 0 : t.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((o)=>o !== "")), Ps(Qn(Qn({}, r), t), {
            url: (t === null || t === void 0 ? void 0 : t.url) || r.url,
            name: (t === null || t === void 0 ? void 0 : t.name) || r.name,
            description: (t === null || t === void 0 ? void 0 : t.description) || r.description,
            icons: (n = t === null || t === void 0 ? void 0 : t.icons) != null && n.length && t.icons.length > 0 ? t.icons : r.icons
        });
    } catch (o) {
        return console.warn("Error populating app metadata", o), t || r;
    }
}
function sr() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$metadata$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWindowMetadata"])() || {
        name: "",
        description: "",
        url: "",
        icons: [
            ""
        ]
    };
}
function Fs(t, e) {
    var n;
    const r = Pt(), o = {
        protocol: t,
        version: e,
        env: r
    };
    return r === "browser" && (o.host = ((n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLocation"])()) == null ? void 0 : n.host) || "unknown"), o;
}
function ir() {
    if (Pt() === J.reactNative && ("TURBOPACK compile-time value", "object") < "u" && typeof (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).Platform) < "u") {
        const { OS: n, Version: r } = ("TURBOPACK ident replacement", globalThis).Platform;
        return [
            n,
            r
        ].join("-");
    }
    const t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$detect$2d$browser$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["detect"])();
    if (t === null) return "unknown";
    const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
    return t.type === "browser" ? [
        e,
        t.name,
        t.version
    ].join("-") : [
        e,
        t.version
    ].join("-");
}
function fr() {
    var t;
    const e = Pt();
    return e === J.browser ? [
        e,
        ((t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLocation"])()) == null ? void 0 : t.host) || "unknown"
    ].join(":") : e;
}
function cr(t, e, n) {
    const r = ir(), o = fr();
    return [
        [
            t,
            e
        ].join("-"),
        [
            rr,
            n
        ].join("-"),
        r,
        o
    ].join("/");
}
function zs(param) {
    let { protocol: t, version: e, relayUrl: n, sdkVersion: r, auth: o, projectId: s, useOnCloseEvent: i, bundleId: f, packageName: a } = param;
    const l = n.split("?"), c = cr(t, e, r), u = {
        auth: o,
        ua: c,
        projectId: s,
        useOnCloseEvent: i || void 0,
        packageName: a || void 0,
        bundleId: f || void 0
    }, h = or(l[1] || "", u);
    return l[0] + "?" + h;
}
function Gs(t) {
    let e = (t.match(/^[^:]+(?=:\/\/)/gi) || [])[0];
    const n = typeof e < "u" ? t.split("://")[1] : t;
    return e = e === "wss" ? "https" : "http", [
        e,
        n
    ].join("://");
}
function Zs(t, e, n) {
    if (!t[e] || typeof t[e] !== n) throw new Error('Missing or invalid "'.concat(e, '" param'));
}
function ar(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : We;
    return ur(t.split(nr), e);
}
function Ws(t) {
    return ar(t).join(Ee);
}
function It(t, e) {
    return t.filter((n)=>e.includes(n)).length === t.length;
}
function ur(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : We;
    return t.slice(Math.max(t.length - e, 0));
}
function Ys(t) {
    return Object.fromEntries(t.entries());
}
function Xs(t) {
    return new Map(Object.entries(t));
}
function Js(t, e) {
    const n = {};
    return Object.keys(t).forEach((r)=>{
        n[r] = e(t[r]);
    }), n;
}
const Qs = (t)=>t;
function lr(t) {
    return t.trim().replace(/^\w/, (e)=>e.toUpperCase());
}
function ti(t) {
    return t.split(Ee).map((e)=>lr(e)).join(Ee);
}
function ei() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$time$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FIVE_MINUTES"], e = arguments.length > 1 ? arguments[1] : void 0;
    const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$time$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMiliseconds"])(t || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$time$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FIVE_MINUTES"]);
    let r, o, s, i;
    return {
        resolve: (f)=>{
            s && r && (clearTimeout(s), r(f), i = Promise.resolve(f));
        },
        reject: (f)=>{
            s && o && (clearTimeout(s), o(f));
        },
        done: ()=>new Promise((f, a)=>{
                if (i) return f(i);
                s = setTimeout(()=>{
                    const l = new Error(e);
                    i = Promise.reject(l), a(l);
                }, n), r = f, o = a;
            })
    };
}
function ni(t, e, n) {
    return new Promise(async (r, o)=>{
        const s = setTimeout(()=>o(new Error(n)), e);
        try {
            const i = await t;
            r(i);
        } catch (i) {
            o(i);
        }
        clearTimeout(s);
    });
}
function Xe(t, e) {
    if (typeof e == "string" && e.startsWith("".concat(t, ":"))) return e;
    if (t.toLowerCase() === "topic") {
        if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
        return "topic:".concat(e);
    } else if (t.toLowerCase() === "id") {
        if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
        return "id:".concat(e);
    }
    throw new Error("Unknown expirer target type: ".concat(t));
}
function ri(t) {
    return Xe("topic", t);
}
function oi(t) {
    return Xe("id", t);
}
function si(t) {
    const [e, n] = t.split(":"), r = {
        id: void 0,
        topic: void 0
    };
    if (e === "topic" && typeof n == "string") r.topic = n;
    else if (e === "id" && Number.isInteger(Number(n))) r.id = Number(n);
    else throw new Error("Invalid target, expected id:number or topic:string, got ".concat(e, ":").concat(n));
    return r;
}
function ii(t, e) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$time$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromMiliseconds"])((e || Date.now()) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$time$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMiliseconds"])(t));
}
function fi(t) {
    return Date.now() >= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$time$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toMiliseconds"])(t);
}
function ci(t, e) {
    return "".concat(t).concat(e ? ":".concat(e) : "");
}
function ct() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return [
        ...new Set([
            ...t,
            ...e
        ])
    ];
}
async function ai(param) {
    let { id: t, topic: e, wcDeepLink: n } = param;
    var r;
    try {
        if (!n) return;
        const o = typeof n == "string" ? JSON.parse(n) : n, s = o === null || o === void 0 ? void 0 : o.href;
        if (typeof s != "string") return;
        const i = dr(s, t, e), f = Pt();
        if (f === J.browser) {
            if (!((r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])()) != null && r.hasFocus())) {
                console.warn("Document does not have focus, skipping deeplink.");
                return;
            }
            hr(i);
        } else f === J.reactNative && typeof (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).Linking) < "u" && await ("TURBOPACK ident replacement", globalThis).Linking.openURL(i);
    } catch (o) {
        console.error(o);
    }
}
function dr(t, e, n) {
    const r = "requestId=".concat(e, "&sessionTopic=").concat(n);
    t.endsWith("/") && (t = t.slice(0, -1));
    let o = "".concat(t);
    if (t.startsWith("https://t.me")) {
        const s = t.includes("?") ? "&startapp=" : "?startapp=";
        o = "".concat(o).concat(s).concat(br(r, !0));
    } else o = "".concat(o, "/wc?").concat(r);
    return o;
}
function hr(t) {
    let e = "_self";
    gr() ? e = "_top" : (pr() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function ui(t, e) {
    let n = "";
    try {
        if (zt() && (n = localStorage.getItem(e), n)) return n;
        n = await t.getItem(e);
    } catch (r) {
        console.error(r);
    }
    return n;
}
function Je(t, e) {
    return t.filter((n)=>e.includes(n));
}
function li(t, e) {
    if (!t.includes(e)) return null;
    const n = t.split(/([&,?,=])/), r = n.indexOf(e);
    return n[r + 2];
}
function di() {
    return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t)=>{
        const e = Math.random() * 16 | 0;
        return (t === "x" ? e : e & 3 | 8).toString(16);
    });
}
function hi() {
    return typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] < "u" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.IS_VITEST === "true";
}
function pr() {
    return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function gr() {
    try {
        return window.self !== window.top;
    } catch (e) {
        return !1;
    }
}
function br(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t).toString("base64");
    return e ? n.replace(/[=]/g, "") : n;
}
function Qe(t) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t, "base64").toString("utf-8");
}
function pi(t) {
    return new Promise((e)=>setTimeout(e, t));
}
class gi {
    add(e) {
        if (!this.set.has(e)) {
            if (this.set.size >= this.limit) {
                const n = this.set.values().next().value;
                n && this.set.delete(n);
            }
            this.set.add(e);
        }
    }
    has(e) {
        return this.set.has(e);
    }
    constructor({ limit: e }){
        tr(this, "limit"), tr(this, "set"), this.limit = e, this.set = new Set;
    }
}
const Be = BigInt(2 ** 32 - 1), yr = BigInt(32);
function mr(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return e ? {
        h: Number(t & Be),
        l: Number(t >> yr & Be)
    } : {
        h: Number(t >> yr & Be) | 0,
        l: Number(t & Be) | 0
    };
}
function wr(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const n = t.length;
    let r = new Uint32Array(n), o = new Uint32Array(n);
    for(let s = 0; s < n; s++){
        const { h: i, l: f } = mr(t[s], e);
        [r[s], o[s]] = [
            i,
            f
        ];
    }
    return [
        r,
        o
    ];
}
const xr = (t, e, n)=>t >>> n, vr = (t, e, n)=>t << 32 - n | e >>> n, At = (t, e, n)=>t >>> n | e << 32 - n, St = (t, e, n)=>t << 32 - n | e >>> n, se = (t, e, n)=>t << 64 - n | e >>> n - 32, ie = (t, e, n)=>t >>> n - 32 | e << 64 - n, bi = (t, e)=>e, yi = (t, e)=>t, mi = (t, e, n)=>t << n | e >>> 32 - n, wi = (t, e, n)=>e << n | t >>> 32 - n, xi = (t, e, n)=>e << n - 32 | t >>> 64 - n, vi = (t, e, n)=>t << n - 32 | e >>> 64 - n;
function dt(t, e, n, r) {
    const o = (e >>> 0) + (r >>> 0);
    return {
        h: t + n + (o / 2 ** 32 | 0) | 0,
        l: o | 0
    };
}
const tn = (t, e, n)=>(t >>> 0) + (e >>> 0) + (n >>> 0), en = (t, e, n, r)=>e + n + r + (t / 2 ** 32 | 0) | 0, Ei = (t, e, n, r)=>(t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), Bi = (t, e, n, r, o)=>e + n + r + o + (t / 2 ** 32 | 0) | 0, Ii = (t, e, n, r, o)=>(t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (o >>> 0), Ai = (t, e, n, r, o, s)=>e + n + r + o + s + (t / 2 ** 32 | 0) | 0, Gt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function nn(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function mt(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function at(t) {
    for(var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        e[_key - 1] = arguments[_key];
    }
    if (!nn(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function rn(t) {
    if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
    mt(t.outputLen), mt(t.blockLen);
}
function Nt(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function on(t, e) {
    at(t);
    const n = e.outputLen;
    if (t.length < n) throw new Error("digestInto() expects output buffer of length at least " + n);
}
function fe(t) {
    return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function ut() {
    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
        t[_key] = arguments[_key];
    }
    for(let e = 0; e < t.length; e++)t[e].fill(0);
}
function sn(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function gt(t, e) {
    return t << 32 - e | t >>> e;
}
const Er = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
function Br(t) {
    return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
const wt = Er ? (t)=>t : (t)=>Br(t);
function Si(t) {
    for(let e = 0; e < t.length; e++)t[e] = Br(t[e]);
    return t;
}
const Ot = Er ? (t)=>t : Si, Ir = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", Ni = Array.from({
    length: 256
}, (t, e)=>e.toString(16).padStart(2, "0"));
function ce(t) {
    if (at(t), Ir) return t.toHex();
    let e = "";
    for(let n = 0; n < t.length; n++)e += Ni[t[n]];
    return e;
}
const xt = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function Ar(t) {
    if (t >= xt._0 && t <= xt._9) return t - xt._0;
    if (t >= xt.A && t <= xt.F) return t - (xt.A - 10);
    if (t >= xt.a && t <= xt.f) return t - (xt.a - 10);
}
function fn(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    if (Ir) return Uint8Array.fromHex(t);
    const e = t.length, n = e / 2;
    if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
    const r = new Uint8Array(n);
    for(let o = 0, s = 0; o < n; o++, s += 2){
        const i = Ar(t.charCodeAt(s)), f = Ar(t.charCodeAt(s + 1));
        if (i === void 0 || f === void 0) {
            const a = t[s] + t[s + 1];
            throw new Error('hex string expected, got non-hex character "' + a + '" at index ' + s);
        }
        r[o] = i * 16 + f;
    }
    return r;
}
function Oi(t) {
    if (typeof t != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(t));
}
function ht(t) {
    return typeof t == "string" && (t = Oi(t)), at(t), t;
}
function Ht() {
    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
        t[_key] = arguments[_key];
    }
    let e = 0;
    for(let r = 0; r < t.length; r++){
        const o = t[r];
        at(o), e += o.length;
    }
    const n = new Uint8Array(e);
    for(let r = 0, o = 0; r < t.length; r++){
        const s = t[r];
        n.set(s, o), o += s.length;
    }
    return n;
}
class Ie {
}
function ae(t) {
    const e = (r)=>t().update(ht(r)).digest(), n = t();
    return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = ()=>t(), e;
}
function Ui(t) {
    const e = (r, o)=>t(o).update(ht(r)).digest(), n = t({});
    return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = (r)=>t(r), e;
}
function Zt() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;
    if (Gt && typeof Gt.getRandomValues == "function") return Gt.getRandomValues(new Uint8Array(t));
    if (Gt && typeof Gt.randomBytes == "function") return Uint8Array.from(Gt.randomBytes(t));
    throw new Error("crypto.getRandomValues must be defined");
}
const _i = BigInt(0), ue = BigInt(1), Ti = BigInt(2), Ri = BigInt(7), $i = BigInt(256), Ci = BigInt(113), Sr = [], Nr = [], Or = [];
for(let t = 0, e = ue, n = 1, r = 0; t < 24; t++){
    [n, r] = [
        r,
        (2 * n + 3 * r) % 5
    ], Sr.push(2 * (5 * r + n)), Nr.push((t + 1) * (t + 2) / 2 % 64);
    let o = _i;
    for(let s = 0; s < 7; s++)e = (e << ue ^ (e >> Ri) * Ci) % $i, e & Ti && (o ^= ue << (ue << BigInt(s)) - ue);
    Or.push(o);
}
const Ur = wr(Or, !0), Li = Ur[0], ji = Ur[1], _r = (t, e, n)=>n > 32 ? xi(t, e, n) : mi(t, e, n), Tr = (t, e, n)=>n > 32 ? vi(t, e, n) : wi(t, e, n);
function ki(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 24;
    const n = new Uint32Array(10);
    for(let r = 24 - e; r < 24; r++){
        for(let i = 0; i < 10; i++)n[i] = t[i] ^ t[i + 10] ^ t[i + 20] ^ t[i + 30] ^ t[i + 40];
        for(let i = 0; i < 10; i += 2){
            const f = (i + 8) % 10, a = (i + 2) % 10, l = n[a], c = n[a + 1], u = _r(l, c, 1) ^ n[f], h = Tr(l, c, 1) ^ n[f + 1];
            for(let g = 0; g < 50; g += 10)t[i + g] ^= u, t[i + g + 1] ^= h;
        }
        let o = t[2], s = t[3];
        for(let i = 0; i < 24; i++){
            const f = Nr[i], a = _r(o, s, f), l = Tr(o, s, f), c = Sr[i];
            o = t[c], s = t[c + 1], t[c] = a, t[c + 1] = l;
        }
        for(let i = 0; i < 50; i += 10){
            for(let f = 0; f < 10; f++)n[f] = t[i + f];
            for(let f = 0; f < 10; f++)t[i + f] ^= ~n[(f + 2) % 10] & n[(f + 4) % 10];
        }
        t[0] ^= Li[r], t[1] ^= ji[r];
    }
    ut(n);
}
class qn extends Ie {
    clone() {
        return this._cloneInto();
    }
    keccak() {
        Ot(this.state32), ki(this.state32, this.rounds), Ot(this.state32), this.posOut = 0, this.pos = 0;
    }
    update(e) {
        Nt(this), e = ht(e), at(e);
        const { blockLen: n, state: r } = this, o = e.length;
        for(let s = 0; s < o;){
            const i = Math.min(n - this.pos, o - s);
            for(let f = 0; f < i; f++)r[this.pos++] ^= e[s++];
            this.pos === n && this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = !0;
        const { state: e, suffix: n, pos: r, blockLen: o } = this;
        e[r] ^= n, (n & 128) !== 0 && r === o - 1 && this.keccak(), e[o - 1] ^= 128, this.keccak();
    }
    writeInto(e) {
        Nt(this, !1), at(e), this.finish();
        const n = this.state, { blockLen: r } = this;
        for(let o = 0, s = e.length; o < s;){
            this.posOut >= r && this.keccak();
            const i = Math.min(r - this.posOut, s - o);
            e.set(n.subarray(this.posOut, this.posOut + i), o), this.posOut += i, o += i;
        }
        return e;
    }
    xofInto(e) {
        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
        return this.writeInto(e);
    }
    xof(e) {
        return mt(e), this.xofInto(new Uint8Array(e));
    }
    digestInto(e) {
        if (on(e, this), this.finished) throw new Error("digest() was already called");
        return this.writeInto(e), this.destroy(), e;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = !0, ut(this.state);
    }
    _cloneInto(e) {
        const { blockLen: n, suffix: r, outputLen: o, rounds: s, enableXOF: i } = this;
        return e || (e = new qn(n, r, o, i, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r, e.outputLen = o, e.enableXOF = i, e.destroyed = this.destroyed, e;
    }
    constructor(e, n, r, o = !1, s = 24){
        if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = o, this.rounds = s, mt(r), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200), this.state32 = fe(this.state);
    }
}
const Pi = (t, e, n)=>ae(()=>new qn(e, t, n)), Hi = Pi(1, 136, 256 / 8);
function Di(t, e, n, r) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
    const o = BigInt(32), s = BigInt(4294967295), i = Number(n >> o & s), f = Number(n & s), a = r ? 4 : 0, l = r ? 0 : 4;
    t.setUint32(e + a, i, r), t.setUint32(e + l, f, r);
}
function Mi(t, e, n) {
    return t & e ^ ~t & n;
}
function Vi(t, e, n) {
    return t & e ^ t & n ^ e & n;
}
class Rr extends Ie {
    update(e) {
        Nt(this), e = ht(e), at(e);
        const { view: n, buffer: r, blockLen: o } = this, s = e.length;
        for(let i = 0; i < s;){
            const f = Math.min(o - this.pos, s - i);
            if (f === o) {
                const a = sn(e);
                for(; o <= s - i; i += o)this.process(a, i);
                continue;
            }
            r.set(e.subarray(i, i + f), this.pos), this.pos += f, i += f, this.pos === o && (this.process(n, 0), this.pos = 0);
        }
        return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
        Nt(this), on(e, this), this.finished = !0;
        const { buffer: n, view: r, blockLen: o, isLE: s } = this;
        let { pos: i } = this;
        n[i++] = 128, ut(this.buffer.subarray(i)), this.padOffset > o - i && (this.process(r, 0), i = 0);
        for(let u = i; u < o; u++)n[u] = 0;
        Di(r, o - 8, BigInt(this.length * 8), s), this.process(r, 0);
        const f = sn(e), a = this.outputLen;
        if (a % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
        const l = a / 4, c = this.get();
        if (l > c.length) throw new Error("_sha2: outputLen bigger than state");
        for(let u = 0; u < l; u++)f.setUint32(4 * u, c[u], s);
    }
    digest() {
        const { buffer: e, outputLen: n } = this;
        this.digestInto(e);
        const r = e.slice(0, n);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        e || (e = new this.constructor), e.set(...this.get());
        const { blockLen: n, buffer: r, length: o, finished: s, destroyed: i, pos: f } = this;
        return e.destroyed = i, e.finished = s, e.length = o, e.pos = f, o % n && e.buffer.set(r), e;
    }
    clone() {
        return this._cloneInto();
    }
    constructor(e, n, r, o){
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = o, this.buffer = new Uint8Array(e), this.view = sn(this.buffer);
    }
}
const Ut = Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
]), W = Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
]), Y = Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
]), qi = Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
]), _t = new Uint32Array(64);
class Ki extends Rr {
    get() {
        const { A: e, B: n, C: r, D: o, E: s, F: i, G: f, H: a } = this;
        return [
            e,
            n,
            r,
            o,
            s,
            i,
            f,
            a
        ];
    }
    set(e, n, r, o, s, i, f, a) {
        this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = o | 0, this.E = s | 0, this.F = i | 0, this.G = f | 0, this.H = a | 0;
    }
    process(e, n) {
        for(let u = 0; u < 16; u++, n += 4)_t[u] = e.getUint32(n, !1);
        for(let u = 16; u < 64; u++){
            const h = _t[u - 15], g = _t[u - 2], w = gt(h, 7) ^ gt(h, 18) ^ h >>> 3, y = gt(g, 17) ^ gt(g, 19) ^ g >>> 10;
            _t[u] = y + _t[u - 7] + w + _t[u - 16] | 0;
        }
        let { A: r, B: o, C: s, D: i, E: f, F: a, G: l, H: c } = this;
        for(let u = 0; u < 64; u++){
            const h = gt(f, 6) ^ gt(f, 11) ^ gt(f, 25), g = c + h + Mi(f, a, l) + qi[u] + _t[u] | 0, y = (gt(r, 2) ^ gt(r, 13) ^ gt(r, 22)) + Vi(r, o, s) | 0;
            c = l, l = a, a = f, f = i + g | 0, i = s, s = o, o = r, r = g + y | 0;
        }
        r = r + this.A | 0, o = o + this.B | 0, s = s + this.C | 0, i = i + this.D | 0, f = f + this.E | 0, a = a + this.F | 0, l = l + this.G | 0, c = c + this.H | 0, this.set(r, o, s, i, f, a, l, c);
    }
    roundClean() {
        ut(_t);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), ut(this.buffer);
    }
    constructor(e = 32){
        super(64, e, 8, !1), this.A = Ut[0] | 0, this.B = Ut[1] | 0, this.C = Ut[2] | 0, this.D = Ut[3] | 0, this.E = Ut[4] | 0, this.F = Ut[5] | 0, this.G = Ut[6] | 0, this.H = Ut[7] | 0;
    }
}
const $r = wr([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
].map((t)=>BigInt(t))), Fi = $r[0], zi = $r[1], Tt = new Uint32Array(80), Rt = new Uint32Array(80);
class cn extends Rr {
    get() {
        const { Ah: e, Al: n, Bh: r, Bl: o, Ch: s, Cl: i, Dh: f, Dl: a, Eh: l, El: c, Fh: u, Fl: h, Gh: g, Gl: w, Hh: y, Hl: x } = this;
        return [
            e,
            n,
            r,
            o,
            s,
            i,
            f,
            a,
            l,
            c,
            u,
            h,
            g,
            w,
            y,
            x
        ];
    }
    set(e, n, r, o, s, i, f, a, l, c, u, h, g, w, y, x) {
        this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = o | 0, this.Ch = s | 0, this.Cl = i | 0, this.Dh = f | 0, this.Dl = a | 0, this.Eh = l | 0, this.El = c | 0, this.Fh = u | 0, this.Fl = h | 0, this.Gh = g | 0, this.Gl = w | 0, this.Hh = y | 0, this.Hl = x | 0;
    }
    process(e, n) {
        for(let L = 0; L < 16; L++, n += 4)Tt[L] = e.getUint32(n), Rt[L] = e.getUint32(n += 4);
        for(let L = 16; L < 80; L++){
            const V = Tt[L - 15] | 0, _ = Rt[L - 15] | 0, k = At(V, _, 1) ^ At(V, _, 8) ^ xr(V, _, 7), j = St(V, _, 1) ^ St(V, _, 8) ^ vr(V, _, 7), $ = Tt[L - 2] | 0, d = Rt[L - 2] | 0, m = At($, d, 19) ^ se($, d, 61) ^ xr($, d, 6), p = St($, d, 19) ^ ie($, d, 61) ^ vr($, d, 6), b = Ei(j, p, Rt[L - 7], Rt[L - 16]), v = Bi(b, k, m, Tt[L - 7], Tt[L - 16]);
            Tt[L] = v | 0, Rt[L] = b | 0;
        }
        let { Ah: r, Al: o, Bh: s, Bl: i, Ch: f, Cl: a, Dh: l, Dl: c, Eh: u, El: h, Fh: g, Fl: w, Gh: y, Gl: x, Hh: R, Hl: M } = this;
        for(let L = 0; L < 80; L++){
            const V = At(u, h, 14) ^ At(u, h, 18) ^ se(u, h, 41), _ = St(u, h, 14) ^ St(u, h, 18) ^ ie(u, h, 41), k = u & g ^ ~u & y, j = h & w ^ ~h & x, $ = Ii(M, _, j, zi[L], Rt[L]), d = Ai($, R, V, k, Fi[L], Tt[L]), m = $ | 0, p = At(r, o, 28) ^ se(r, o, 34) ^ se(r, o, 39), b = St(r, o, 28) ^ ie(r, o, 34) ^ ie(r, o, 39), v = r & s ^ r & f ^ s & f, B = o & i ^ o & a ^ i & a;
            R = y | 0, M = x | 0, y = g | 0, x = w | 0, g = u | 0, w = h | 0, ({ h: u, l: h } = dt(l | 0, c | 0, d | 0, m | 0)), l = f | 0, c = a | 0, f = s | 0, a = i | 0, s = r | 0, i = o | 0;
            const E = tn(m, b, B);
            r = en(E, d, p, v), o = E | 0;
        }
        ({ h: r, l: o } = dt(this.Ah | 0, this.Al | 0, r | 0, o | 0)), ({ h: s, l: i } = dt(this.Bh | 0, this.Bl | 0, s | 0, i | 0)), ({ h: f, l: a } = dt(this.Ch | 0, this.Cl | 0, f | 0, a | 0)), ({ h: l, l: c } = dt(this.Dh | 0, this.Dl | 0, l | 0, c | 0)), ({ h: u, l: h } = dt(this.Eh | 0, this.El | 0, u | 0, h | 0)), ({ h: g, l: w } = dt(this.Fh | 0, this.Fl | 0, g | 0, w | 0)), ({ h: y, l: x } = dt(this.Gh | 0, this.Gl | 0, y | 0, x | 0)), ({ h: R, l: M } = dt(this.Hh | 0, this.Hl | 0, R | 0, M | 0)), this.set(r, o, s, i, f, a, l, c, u, h, g, w, y, x, R, M);
    }
    roundClean() {
        ut(Tt, Rt);
    }
    destroy() {
        ut(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    constructor(e = 64){
        super(128, e, 16, !1), this.Ah = Y[0] | 0, this.Al = Y[1] | 0, this.Bh = Y[2] | 0, this.Bl = Y[3] | 0, this.Ch = Y[4] | 0, this.Cl = Y[5] | 0, this.Dh = Y[6] | 0, this.Dl = Y[7] | 0, this.Eh = Y[8] | 0, this.El = Y[9] | 0, this.Fh = Y[10] | 0, this.Fl = Y[11] | 0, this.Gh = Y[12] | 0, this.Gl = Y[13] | 0, this.Hh = Y[14] | 0, this.Hl = Y[15] | 0;
    }
}
class Gi extends cn {
    constructor(){
        super(48), this.Ah = W[0] | 0, this.Al = W[1] | 0, this.Bh = W[2] | 0, this.Bl = W[3] | 0, this.Ch = W[4] | 0, this.Cl = W[5] | 0, this.Dh = W[6] | 0, this.Dl = W[7] | 0, this.Eh = W[8] | 0, this.El = W[9] | 0, this.Fh = W[10] | 0, this.Fl = W[11] | 0, this.Gh = W[12] | 0, this.Gl = W[13] | 0, this.Hh = W[14] | 0, this.Hl = W[15] | 0;
    }
}
const X = Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
]);
class Zi extends cn {
    constructor(){
        super(32), this.Ah = X[0] | 0, this.Al = X[1] | 0, this.Bh = X[2] | 0, this.Bl = X[3] | 0, this.Ch = X[4] | 0, this.Cl = X[5] | 0, this.Dh = X[6] | 0, this.Dl = X[7] | 0, this.Eh = X[8] | 0, this.El = X[9] | 0, this.Fh = X[10] | 0, this.Fl = X[11] | 0, this.Gh = X[12] | 0, this.Gl = X[13] | 0, this.Hh = X[14] | 0, this.Hl = X[15] | 0;
    }
}
const Ae = ae(()=>new Ki), Wi = ae(()=>new cn), Yi = ae(()=>new Gi), Xi = ae(()=>new Zi), Ji = Uint8Array.from([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9
]), F = Uint32Array.from([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
]), N = new Uint32Array(32);
function $t(t, e, n, r, o, s) {
    const i = o[s], f = o[s + 1];
    let a = N[2 * t], l = N[2 * t + 1], c = N[2 * e], u = N[2 * e + 1], h = N[2 * n], g = N[2 * n + 1], w = N[2 * r], y = N[2 * r + 1], x = tn(a, c, i);
    l = en(x, l, u, f), a = x | 0, ({ Dh: y, Dl: w } = {
        Dh: y ^ l,
        Dl: w ^ a
    }), ({ Dh: y, Dl: w } = {
        Dh: bi(y, w),
        Dl: yi(y)
    }), ({ h: g, l: h } = dt(g, h, y, w)), ({ Bh: u, Bl: c } = {
        Bh: u ^ g,
        Bl: c ^ h
    }), ({ Bh: u, Bl: c } = {
        Bh: At(u, c, 24),
        Bl: St(u, c, 24)
    }), N[2 * t] = a, N[2 * t + 1] = l, N[2 * e] = c, N[2 * e + 1] = u, N[2 * n] = h, N[2 * n + 1] = g, N[2 * r] = w, N[2 * r + 1] = y;
}
function Ct(t, e, n, r, o, s) {
    const i = o[s], f = o[s + 1];
    let a = N[2 * t], l = N[2 * t + 1], c = N[2 * e], u = N[2 * e + 1], h = N[2 * n], g = N[2 * n + 1], w = N[2 * r], y = N[2 * r + 1], x = tn(a, c, i);
    l = en(x, l, u, f), a = x | 0, ({ Dh: y, Dl: w } = {
        Dh: y ^ l,
        Dl: w ^ a
    }), ({ Dh: y, Dl: w } = {
        Dh: At(y, w, 16),
        Dl: St(y, w, 16)
    }), ({ h: g, l: h } = dt(g, h, y, w)), ({ Bh: u, Bl: c } = {
        Bh: u ^ g,
        Bl: c ^ h
    }), ({ Bh: u, Bl: c } = {
        Bh: se(u, c, 63),
        Bl: ie(u, c, 63)
    }), N[2 * t] = a, N[2 * t + 1] = l, N[2 * e] = c, N[2 * e + 1] = u, N[2 * n] = h, N[2 * n + 1] = g, N[2 * r] = w, N[2 * r + 1] = y;
}
function Qi(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0, r = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0;
    if (mt(n), t < 0 || t > n) throw new Error("outputLen bigger than keyLen");
    const { key: s, salt: i, personalization: f } = e;
    if (s !== void 0 && (s.length < 1 || s.length > n)) throw new Error("key length must be undefined or 1.." + n);
    if (i !== void 0 && i.length !== r) throw new Error("salt must be undefined or " + r);
    if (f !== void 0 && f.length !== o) throw new Error("personalization must be undefined or " + o);
}
class tf extends Ie {
    update(e) {
        Nt(this), e = ht(e), at(e);
        const { blockLen: n, buffer: r, buffer32: o } = this, s = e.length, i = e.byteOffset, f = e.buffer;
        for(let a = 0; a < s;){
            this.pos === n && (Ot(o), this.compress(o, 0, !1), Ot(o), this.pos = 0);
            const l = Math.min(n - this.pos, s - a), c = i + a;
            if (l === n && !(c % 4) && a + l < s) {
                const u = new Uint32Array(f, c, Math.floor((s - a) / 4));
                Ot(u);
                for(let h = 0; a + n < s; h += o.length, a += n)this.length += n, this.compress(u, h, !1);
                Ot(u);
                continue;
            }
            r.set(e.subarray(a, a + l), this.pos), this.pos += l, this.length += l, a += l;
        }
        return this;
    }
    digestInto(e) {
        Nt(this), on(e, this);
        const { pos: n, buffer32: r } = this;
        this.finished = !0, ut(this.buffer.subarray(n)), Ot(r), this.compress(r, 0, !0), Ot(r);
        const o = fe(e);
        this.get().forEach((s, i)=>o[i] = wt(s));
    }
    digest() {
        const { buffer: e, outputLen: n } = this;
        this.digestInto(e);
        const r = e.slice(0, n);
        return this.destroy(), r;
    }
    _cloneInto(e) {
        const { buffer: n, length: r, finished: o, destroyed: s, outputLen: i, pos: f } = this;
        return e || (e = new this.constructor({
            dkLen: i
        })), e.set(...this.get()), e.buffer.set(n), e.destroyed = s, e.finished = o, e.length = r, e.pos = f, e.outputLen = i, e;
    }
    clone() {
        return this._cloneInto();
    }
    constructor(e, n){
        super(), this.finished = !1, this.destroyed = !1, this.length = 0, this.pos = 0, mt(e), mt(n), this.blockLen = e, this.outputLen = n, this.buffer = new Uint8Array(e), this.buffer32 = fe(this.buffer);
    }
}
class ef extends tf {
    get() {
        let { v0l: e, v0h: n, v1l: r, v1h: o, v2l: s, v2h: i, v3l: f, v3h: a, v4l: l, v4h: c, v5l: u, v5h: h, v6l: g, v6h: w, v7l: y, v7h: x } = this;
        return [
            e,
            n,
            r,
            o,
            s,
            i,
            f,
            a,
            l,
            c,
            u,
            h,
            g,
            w,
            y,
            x
        ];
    }
    set(e, n, r, o, s, i, f, a, l, c, u, h, g, w, y, x) {
        this.v0l = e | 0, this.v0h = n | 0, this.v1l = r | 0, this.v1h = o | 0, this.v2l = s | 0, this.v2h = i | 0, this.v3l = f | 0, this.v3h = a | 0, this.v4l = l | 0, this.v4h = c | 0, this.v5l = u | 0, this.v5h = h | 0, this.v6l = g | 0, this.v6h = w | 0, this.v7l = y | 0, this.v7h = x | 0;
    }
    compress(e, n, r) {
        this.get().forEach((a, l)=>N[l] = a), N.set(F, 16);
        let { h: o, l: s } = mr(BigInt(this.length));
        N[24] = F[8] ^ s, N[25] = F[9] ^ o, r && (N[28] = ~N[28], N[29] = ~N[29]);
        let i = 0;
        const f = Ji;
        for(let a = 0; a < 12; a++)$t(0, 4, 8, 12, e, n + 2 * f[i++]), Ct(0, 4, 8, 12, e, n + 2 * f[i++]), $t(1, 5, 9, 13, e, n + 2 * f[i++]), Ct(1, 5, 9, 13, e, n + 2 * f[i++]), $t(2, 6, 10, 14, e, n + 2 * f[i++]), Ct(2, 6, 10, 14, e, n + 2 * f[i++]), $t(3, 7, 11, 15, e, n + 2 * f[i++]), Ct(3, 7, 11, 15, e, n + 2 * f[i++]), $t(0, 5, 10, 15, e, n + 2 * f[i++]), Ct(0, 5, 10, 15, e, n + 2 * f[i++]), $t(1, 6, 11, 12, e, n + 2 * f[i++]), Ct(1, 6, 11, 12, e, n + 2 * f[i++]), $t(2, 7, 8, 13, e, n + 2 * f[i++]), Ct(2, 7, 8, 13, e, n + 2 * f[i++]), $t(3, 4, 9, 14, e, n + 2 * f[i++]), Ct(3, 4, 9, 14, e, n + 2 * f[i++]);
        this.v0l ^= N[0] ^ N[16], this.v0h ^= N[1] ^ N[17], this.v1l ^= N[2] ^ N[18], this.v1h ^= N[3] ^ N[19], this.v2l ^= N[4] ^ N[20], this.v2h ^= N[5] ^ N[21], this.v3l ^= N[6] ^ N[22], this.v3h ^= N[7] ^ N[23], this.v4l ^= N[8] ^ N[24], this.v4h ^= N[9] ^ N[25], this.v5l ^= N[10] ^ N[26], this.v5h ^= N[11] ^ N[27], this.v6l ^= N[12] ^ N[28], this.v6h ^= N[13] ^ N[29], this.v7l ^= N[14] ^ N[30], this.v7h ^= N[15] ^ N[31], ut(N);
    }
    destroy() {
        this.destroyed = !0, ut(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    constructor(e = {}){
        const n = e.dkLen === void 0 ? 64 : e.dkLen;
        super(128, n), this.v0l = F[0] | 0, this.v0h = F[1] | 0, this.v1l = F[2] | 0, this.v1h = F[3] | 0, this.v2l = F[4] | 0, this.v2h = F[5] | 0, this.v3l = F[6] | 0, this.v3h = F[7] | 0, this.v4l = F[8] | 0, this.v4h = F[9] | 0, this.v5l = F[10] | 0, this.v5h = F[11] | 0, this.v6l = F[12] | 0, this.v6h = F[13] | 0, this.v7l = F[14] | 0, this.v7h = F[15] | 0, Qi(n, e, 64, 16, 16);
        let { key: r, personalization: o, salt: s } = e, i = 0;
        if (r !== void 0 && (r = ht(r), i = r.length), this.v0l ^= this.outputLen | i << 8 | 65536 | 1 << 24, s !== void 0) {
            s = ht(s);
            const f = fe(s);
            this.v4l ^= wt(f[0]), this.v4h ^= wt(f[1]), this.v5l ^= wt(f[2]), this.v5h ^= wt(f[3]);
        }
        if (o !== void 0) {
            o = ht(o);
            const f = fe(o);
            this.v6l ^= wt(f[0]), this.v6h ^= wt(f[1]), this.v7l ^= wt(f[2]), this.v7h ^= wt(f[3]);
        }
        if (r !== void 0) {
            const f = new Uint8Array(this.blockLen);
            f.set(r), this.update(f);
        }
    }
}
const nf = Ui((t)=>new ef(t)), rf = "https://rpc.walletconnect.org/v1";
function an(t) {
    const e = "\x19Ethereum Signed Message:\n".concat(t.length), n = new TextEncoder().encode(e + t);
    return "0x" + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(Hi(n)).toString("hex");
}
async function Cr(t, e, n, r, o, s) {
    switch(n.t){
        case "eip191":
            return await Lr(t, e, n.s);
        case "eip1271":
            return await jr(t, e, n.s, r, o, s);
        default:
            throw new Error("verifySignature failed: Attempted to verify CacaoSignature with unknown type: ".concat(n.t));
    }
}
async function Lr(t, e, n) {
    return (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$signature$2f$recoverAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["recoverAddress"])({
        hash: an(e),
        signature: n
    })).toLowerCase() === t.toLowerCase();
}
async function jr(t, e, n, r, o, s) {
    const i = Fe(r);
    if (!i.namespace || !i.reference) throw new Error("isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ".concat(r));
    try {
        const f = "0x1626ba7e", a = "0000000000000000000000000000000000000000000000000000000000000040", l = n.substring(2), c = (l.length / 2).toString(16).padStart(64, "0"), u = (e.startsWith("0x") ? e : an(e)).substring(2), h = f + u + a + c + l, g = await fetch("".concat(s || rf, "/?chainId=").concat(r, "&projectId=").concat(o), {
            headers: {
                "Content-Type": "application/json"
            },
            method: "POST",
            body: JSON.stringify({
                id: of(),
                jsonrpc: "2.0",
                method: "eth_call",
                params: [
                    {
                        to: t,
                        data: h
                    },
                    "latest"
                ]
            })
        }), { result: w } = await g.json();
        return w ? w.slice(0, f.length).toLowerCase() === f.toLowerCase() : !1;
    } catch (f) {
        return console.error("isValidEip1271Signature: ", f), !1;
    }
}
function of() {
    return Date.now() + Math.floor(Math.random() * 1e3);
}
function sf(t) {
    const e = atob(t), n = new Uint8Array(e.length);
    for(let i = 0; i < e.length; i++)n[i] = e.charCodeAt(i);
    const r = n[0];
    if (r === 0) throw new Error("No signatures found");
    const o = 1 + r * 64;
    if (n.length < o) throw new Error("Transaction data too short for claimed signature count");
    if (n.length < 100) throw new Error("Transaction too short");
    const s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t, "base64").slice(1, 65);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(s);
}
function ff(t) {
    const e = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t, "base64")), n = Array.from("TransactionData::").map((s)=>s.charCodeAt(0)), r = new Uint8Array(n.length + e.length);
    r.set(n), r.set(e, n.length);
    const o = nf(r, {
        dkLen: 32
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(o);
}
function cf(t) {
    const e = new Uint8Array(Ae(kr(t)));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(e);
}
function kr(t) {
    if (t instanceof Uint8Array) return t;
    if (Array.isArray(t)) return new Uint8Array(t);
    if (typeof t == "object" && t != null && t.data) return new Uint8Array(Object.values(t.data));
    if (typeof t == "object" && t) return new Uint8Array(Object.values(t));
    throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function af(t) {
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t, "base64"), n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$esm$2f$decode$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(e).txn;
    if (!n) throw new Error("Invalid signed transaction: missing 'txn' field");
    const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$esm$2f$encode$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(n), o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from("TX"), s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
        o,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r)
    ]), i = Xi(s);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].encode(i).replace(/=+$/, "");
}
function un(t) {
    const e = [];
    let n = BigInt(t);
    for(; n >= BigInt(128);)e.push(Number(n & BigInt(127) | BigInt(128))), n >>= BigInt(7);
    return e.push(Number(n)), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(e);
}
function uf(t) {
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.signed.bodyBytes, "base64"), n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.signed.authInfoBytes, "base64"), r = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.signature.signature, "base64"), o = [];
    o.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
        10
    ])), o.push(un(e.length)), o.push(e), o.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
        18
    ])), o.push(un(n.length)), o.push(n), o.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
        26
    ])), o.push(un(r.length)), o.push(r);
    const s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(o), i = Ae(s);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(i).toString("hex").toUpperCase();
}
var lf = Object.defineProperty, df = Object.defineProperties, hf = Object.getOwnPropertyDescriptors, Pr = Object.getOwnPropertySymbols, pf = Object.prototype.hasOwnProperty, gf = Object.prototype.propertyIsEnumerable, Hr = (t, e, n)=>e in t ? lf(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n, ln = (t, e)=>{
    for(var n in e || (e = {}))pf.call(e, n) && Hr(t, n, e[n]);
    if (Pr) for (var n of Pr(e))gf.call(e, n) && Hr(t, n, e[n]);
    return t;
}, Dr = (t, e)=>df(t, hf(e));
const bf = "did:pkh:", Se = (t)=>t === null || t === void 0 ? void 0 : t.split(":"), Mr = (t)=>{
    const e = t && Se(t);
    if (e) return t.includes(bf) ? e[3] : e[1];
}, Vr = (t)=>{
    const e = t && Se(t);
    if (e) return e[2] + ":" + e[3];
}, dn = (t)=>{
    const e = t && Se(t);
    if (e) return e.pop();
};
async function yf(t) {
    const { cacao: e, projectId: n } = t, { s: r, p: o } = e, s = qr(o, o.iss), i = dn(o.iss);
    return await Cr(i, s, r, Vr(o.iss), n);
}
const qr = (t, e)=>{
    const n = "".concat(t.domain, " wants you to sign in with your Ethereum account:"), r = dn(e);
    if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
    let o = t.statement || void 0;
    const s = "URI: ".concat(t.aud || t.uri), i = "Version: ".concat(t.version), f = "Chain ID: ".concat(Mr(e)), a = "Nonce: ".concat(t.nonce), l = "Issued At: ".concat(t.iat), c = t.exp ? "Expiration Time: ".concat(t.exp) : void 0, u = t.nbf ? "Not Before: ".concat(t.nbf) : void 0, h = t.requestId ? "Request ID: ".concat(t.requestId) : void 0, g = t.resources ? "Resources:".concat(t.resources.map((y)=>"\n- ".concat(y)).join("")) : void 0, w = Oe(t.resources);
    if (w) {
        const y = Lt(w);
        o = gn(o, y);
    }
    return [
        n,
        r,
        "",
        o,
        "",
        s,
        i,
        f,
        a,
        l,
        c,
        u,
        h,
        g
    ].filter((y)=>y != null).join("\n");
};
function mf(t, e, n) {
    return n.includes("did:pkh:") || (n = "did:pkh:".concat(n)), {
        h: {
            t: "caip122"
        },
        p: {
            iss: n,
            domain: t.domain,
            aud: t.aud,
            version: t.version,
            nonce: t.nonce,
            iat: t.iat,
            statement: t.statement,
            requestId: t.requestId,
            resources: t.resources,
            nbf: t.nbf,
            exp: t.exp
        },
        s: e
    };
}
function wf(t) {
    var e;
    const { authPayload: n, chains: r, methods: o } = t, s = n.statement || "";
    if (!(r != null && r.length)) return n;
    const i = n.chains, f = Je(i, r);
    if (!(f != null && f.length)) throw new Error("No supported chains");
    const a = Kr(n.resources);
    if (!a) return n;
    bt(a);
    const l = Fr(a, "eip155");
    let c = (n === null || n === void 0 ? void 0 : n.resources) || [];
    if (l != null && l.length) {
        const u = zr(l), h = Je(u, o);
        if (!(h != null && h.length)) throw new Error("Supported methods don't satisfy the requested: ".concat(JSON.stringify(u), ", supported: ").concat(JSON.stringify(o)));
        const g = hn("request", h, {
            chains: f
        }), w = Yr(a, "eip155", g);
        c = ((e = n === null || n === void 0 ? void 0 : n.resources) == null ? void 0 : e.slice(0, -1)) || [], c.push(Ne(w));
    }
    return Dr(ln({}, n), {
        statement: Jr(s, Oe(c)),
        chains: f,
        resources: n != null && n.resources || c.length > 0 ? c : void 0
    });
}
function Kr(t) {
    const e = Oe(t);
    if (e && pn(e)) return Lt(e);
}
function xf(t, e) {
    var n;
    return (n = t === null || t === void 0 ? void 0 : t.att) == null ? void 0 : n.hasOwnProperty(e);
}
function Fr(t, e) {
    var n, r;
    return (n = t === null || t === void 0 ? void 0 : t.att) != null && n[e] ? Object.keys((r = t === null || t === void 0 ? void 0 : t.att) == null ? void 0 : r[e]) : [];
}
function vf(t) {
    return (t === null || t === void 0 ? void 0 : t.map((e)=>Object.keys(e))) || [];
}
function zr(t) {
    return (t === null || t === void 0 ? void 0 : t.map((e)=>{
        var n;
        return (n = e.split("/")) == null ? void 0 : n[1];
    })) || [];
}
function Gr(t) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(JSON.stringify(t)).toString("base64");
}
function Zr(t) {
    return JSON.parse(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t, "base64").toString("utf-8"));
}
function bt(t) {
    if (!t) throw new Error("No recap provided, value is undefined");
    if (!t.att) throw new Error("No `att` property found");
    const e = Object.keys(t.att);
    if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
    e.forEach((n)=>{
        const r = t.att[n];
        if (Array.isArray(r)) throw new Error("Resource must be an object: ".concat(n));
        if (typeof r != "object") throw new Error("Resource must be an object: ".concat(n));
        if (!Object.keys(r).length) throw new Error("Resource object is empty: ".concat(n));
        Object.keys(r).forEach((o)=>{
            const s = r[o];
            if (!Array.isArray(s)) throw new Error("Ability limits ".concat(o, " must be an array of objects, found: ").concat(s));
            if (!s.length) throw new Error("Value of ".concat(o, " is empty array, must be an array with objects"));
            s.forEach((i)=>{
                if (typeof i != "object") throw new Error("Ability limits (".concat(o, ") must be an array of objects, found: ").concat(i));
            });
        });
    });
}
function Wr(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return n === null || n === void 0 ? void 0 : n.sort((o, s)=>o.localeCompare(s)), {
        att: {
            [t]: hn(e, n, r)
        }
    };
}
function Yr(t, e, n) {
    var r;
    t.att[e] = ln({}, n);
    const o = (r = Object.keys(t.att)) == null ? void 0 : r.sort((i, f)=>i.localeCompare(f)), s = {
        att: {}
    };
    return o.reduce((i, f)=>(i.att[f] = t.att[f], i), s);
}
function hn(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    e = e === null || e === void 0 ? void 0 : e.sort((o, s)=>o.localeCompare(s));
    const r = e.map((o)=>({
            ["".concat(t, "/").concat(o)]: [
                n
            ]
        }));
    return Object.assign({}, ...r);
}
function Ne(t) {
    return bt(t), "urn:recap:".concat(Gr(t).replace(/=/g, ""));
}
function Lt(t) {
    const e = Zr(t.replace("urn:recap:", ""));
    return bt(e), e;
}
function Ef(t, e, n) {
    const r = Wr(t, e, n);
    return Ne(r);
}
function pn(t) {
    return t && t.includes("urn:recap:");
}
function Bf(t, e) {
    const n = Lt(t), r = Lt(e), o = Xr(n, r);
    return Ne(o);
}
function Xr(t, e) {
    bt(t), bt(e);
    const n = Object.keys(t.att).concat(Object.keys(e.att)).sort((o, s)=>o.localeCompare(s)), r = {
        att: {}
    };
    return n.forEach((o)=>{
        var s, i;
        Object.keys(((s = t.att) == null ? void 0 : s[o]) || {}).concat(Object.keys(((i = e.att) == null ? void 0 : i[o]) || {})).sort((f, a)=>f.localeCompare(a)).forEach((f)=>{
            var a, l;
            r.att[o] = Dr(ln({}, r.att[o]), {
                [f]: ((a = t.att[o]) == null ? void 0 : a[f]) || ((l = e.att[o]) == null ? void 0 : l[f])
            });
        });
    }), r;
}
function gn() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0;
    bt(e);
    const n = "I further authorize the stated URI to perform the following actions on my behalf: ";
    if (t.includes(n)) return t;
    const r = [];
    let o = 0;
    Object.keys(e.att).forEach((f)=>{
        const a = Object.keys(e.att[f]).map((u)=>({
                ability: u.split("/")[0],
                action: u.split("/")[1]
            }));
        a.sort((u, h)=>u.action.localeCompare(h.action));
        const l = {};
        a.forEach((u)=>{
            l[u.ability] || (l[u.ability] = []), l[u.ability].push(u.action);
        });
        const c = Object.keys(l).map((u)=>(o++, "(".concat(o, ") '").concat(u, "': '").concat(l[u].join("', '"), "' for '").concat(f, "'.")));
        r.push(c.join(", ").replace(".,", "."));
    });
    const s = r.join(" "), i = "".concat(n).concat(s);
    return "".concat(t ? t + " " : "").concat(i);
}
function If(t) {
    var e;
    const n = Lt(t);
    bt(n);
    const r = (e = n.att) == null ? void 0 : e.eip155;
    return r ? Object.keys(r).map((o)=>o.split("/")[1]) : [];
}
function Af(t) {
    const e = Lt(t);
    bt(e);
    const n = [];
    return Object.values(e.att).forEach((r)=>{
        Object.values(r).forEach((o)=>{
            var s;
            (s = o === null || o === void 0 ? void 0 : o[0]) != null && s.chains && n.push(o[0].chains);
        });
    }), [
        ...new Set(n.flat())
    ];
}
function Jr(t, e) {
    if (!e) return t;
    const n = Lt(e);
    return bt(n), gn(t, n);
}
function Oe(t) {
    if (!t) return;
    const e = t === null || t === void 0 ? void 0 : t[t.length - 1];
    return pn(e) ? e : void 0;
} /*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */ 
function Qr(t) {
    return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function bn(t) {
    if (typeof t != "boolean") throw new Error("boolean expected, not ".concat(t));
}
function yn(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function nt(t) {
    for(var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        e[_key - 1] = arguments[_key];
    }
    if (!Qr(t)) throw new Error("Uint8Array expected");
    if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function to(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Sf(t, e) {
    nt(t);
    const n = e.outputLen;
    if (t.length < n) throw new Error("digestInto() expects output buffer of length at least " + n);
}
function jt(t) {
    return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Wt() {
    for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){
        t[_key] = arguments[_key];
    }
    for(let e = 0; e < t.length; e++)t[e].fill(0);
}
function Nf(t) {
    return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
const Of = new Uint8Array(new Uint32Array([
    287454020
]).buffer)[0] === 68;
function Uf(t) {
    if (typeof t != "string") throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(t));
}
function mn(t) {
    if (typeof t == "string") t = Uf(t);
    else if (Qr(t)) t = wn(t);
    else throw new Error("Uint8Array expected, got " + typeof t);
    return t;
}
function _f(t, e) {
    if (e == null || typeof e != "object") throw new Error("options must be defined");
    return Object.assign(t, e);
}
function Tf(t, e) {
    if (t.length !== e.length) return !1;
    let n = 0;
    for(let r = 0; r < t.length; r++)n |= t[r] ^ e[r];
    return n === 0;
}
const Rf = (t, e)=>{
    function n(r) {
        for(var _len = arguments.length, o = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            o[_key - 1] = arguments[_key];
        }
        if (nt(r), !Of) throw new Error("Non little-endian hardware is not yet supported");
        if (t.nonceLength !== void 0) {
            const c = o[0];
            if (!c) throw new Error("nonce / iv required");
            t.varSizeNonce ? nt(c) : nt(c, t.nonceLength);
        }
        const s = t.tagLength;
        s && o[1] !== void 0 && nt(o[1]);
        const i = e(r, ...o), f = (c, u)=>{
            if (u !== void 0) {
                if (c !== 2) throw new Error("cipher output not supported");
                nt(u);
            }
        };
        let a = !1;
        return {
            encrypt (c, u) {
                if (a) throw new Error("cannot encrypt() twice with same key + nonce");
                return a = !0, nt(c), f(i.encrypt.length, u), i.encrypt(c, u);
            },
            decrypt (c, u) {
                if (nt(c), s && c.length < s) throw new Error("invalid ciphertext length: smaller than tagLength=" + s);
                return f(i.decrypt.length, u), i.decrypt(c, u);
            }
        };
    }
    return Object.assign(n, t), n;
};
function eo(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    if (e === void 0) return new Uint8Array(t);
    if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
    if (n && !Cf(e)) throw new Error("invalid output, must be aligned");
    return e;
}
function no(t, e, n, r) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
    const o = BigInt(32), s = BigInt(4294967295), i = Number(n >> o & s), f = Number(n & s), a = r ? 4 : 0, l = r ? 0 : 4;
    t.setUint32(e + a, i, r), t.setUint32(e + l, f, r);
}
function $f(t, e, n) {
    bn(n);
    const r = new Uint8Array(16), o = Nf(r);
    return no(o, 0, BigInt(e), n), no(o, 8, BigInt(t), n), r;
}
function Cf(t) {
    return t.byteOffset % 4 === 0;
}
function wn(t) {
    return Uint8Array.from(t);
}
const ro = (t)=>Uint8Array.from(t.split("").map((e)=>e.charCodeAt(0))), Lf = ro("expand 16-byte k"), jf = ro("expand 32-byte k"), kf = jt(Lf), Pf = jt(jf);
function D(t, e) {
    return t << e | t >>> 32 - e;
}
function xn(t) {
    return t.byteOffset % 4 === 0;
}
const Ue = 64, Hf = 16, oo = 2 ** 32 - 1, so = new Uint32Array;
function Df(t, e, n, r, o, s, i, f) {
    const a = o.length, l = new Uint8Array(Ue), c = jt(l), u = xn(o) && xn(s), h = u ? jt(o) : so, g = u ? jt(s) : so;
    for(let w = 0; w < a; i++){
        if (t(e, n, r, c, i, f), i >= oo) throw new Error("arx: counter overflow");
        const y = Math.min(Ue, a - w);
        if (u && y === Ue) {
            const x = w / 4;
            if (w % 4 !== 0) throw new Error("arx: invalid block position");
            for(let R = 0, M; R < Hf; R++)M = x + R, g[M] = h[M] ^ c[R];
            w += Ue;
            continue;
        }
        for(let x = 0, R; x < y; x++)R = w + x, s[R] = o[R] ^ l[x];
        w += y;
    }
}
function Mf(t, e) {
    const { allowShortKeys: n, extendNonceFn: r, counterLength: o, counterRight: s, rounds: i } = _f({
        allowShortKeys: !1,
        counterLength: 8,
        counterRight: !1,
        rounds: 20
    }, e);
    if (typeof t != "function") throw new Error("core must be a function");
    return yn(o), yn(i), bn(s), bn(n), function(f, a, l, c) {
        let u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        nt(f), nt(a), nt(l);
        const h = l.length;
        if (c === void 0 && (c = new Uint8Array(h)), nt(c), yn(u), u < 0 || u >= oo) throw new Error("arx: counter overflow");
        if (c.length < h) throw new Error("arx: output (".concat(c.length, ") is shorter than data (").concat(h, ")"));
        const g = [];
        let w = f.length, y, x;
        if (w === 32) g.push(y = wn(f)), x = Pf;
        else if (w === 16 && n) y = new Uint8Array(32), y.set(f), y.set(f, 16), x = kf, g.push(y);
        else throw new Error("arx: invalid 32-byte key, got length=".concat(w));
        xn(a) || g.push(a = wn(a));
        const R = jt(y);
        if (r) {
            if (a.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
            r(x, R, jt(a.subarray(0, 16)), R), a = a.subarray(16);
        }
        const M = 16 - o;
        if (M !== a.length) throw new Error("arx: nonce must be ".concat(M, " or 16 bytes"));
        if (M !== 12) {
            const V = new Uint8Array(12);
            V.set(a, s ? 0 : 12 - a.length), a = V, g.push(a);
        }
        const L = jt(a);
        return Df(t, x, R, L, l, c, u, i), Wt(...g), c;
    };
}
const G = (t, e)=>t[e++] & 255 | (t[e++] & 255) << 8;
class Vf {
    process(e, n) {
        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        const o = r ? 0 : 2048, { h: s, r: i } = this, f = i[0], a = i[1], l = i[2], c = i[3], u = i[4], h = i[5], g = i[6], w = i[7], y = i[8], x = i[9], R = G(e, n + 0), M = G(e, n + 2), L = G(e, n + 4), V = G(e, n + 6), _ = G(e, n + 8), k = G(e, n + 10), j = G(e, n + 12), $ = G(e, n + 14);
        let d = s[0] + (R & 8191), m = s[1] + ((R >>> 13 | M << 3) & 8191), p = s[2] + ((M >>> 10 | L << 6) & 8191), b = s[3] + ((L >>> 7 | V << 9) & 8191), v = s[4] + ((V >>> 4 | _ << 12) & 8191), B = s[5] + (_ >>> 1 & 8191), E = s[6] + ((_ >>> 14 | k << 2) & 8191), I = s[7] + ((k >>> 11 | j << 5) & 8191), S = s[8] + ((j >>> 8 | $ << 8) & 8191), O = s[9] + ($ >>> 5 | o), A = 0, T = A + d * f + m * (5 * x) + p * (5 * y) + b * (5 * w) + v * (5 * g);
        A = T >>> 13, T &= 8191, T += B * (5 * h) + E * (5 * u) + I * (5 * c) + S * (5 * l) + O * (5 * a), A += T >>> 13, T &= 8191;
        let U = A + d * a + m * f + p * (5 * x) + b * (5 * y) + v * (5 * w);
        A = U >>> 13, U &= 8191, U += B * (5 * g) + E * (5 * h) + I * (5 * u) + S * (5 * c) + O * (5 * l), A += U >>> 13, U &= 8191;
        let C = A + d * l + m * a + p * f + b * (5 * x) + v * (5 * y);
        A = C >>> 13, C &= 8191, C += B * (5 * w) + E * (5 * g) + I * (5 * h) + S * (5 * u) + O * (5 * c), A += C >>> 13, C &= 8191;
        let H = A + d * c + m * l + p * a + b * f + v * (5 * x);
        A = H >>> 13, H &= 8191, H += B * (5 * y) + E * (5 * w) + I * (5 * g) + S * (5 * h) + O * (5 * u), A += H >>> 13, H &= 8191;
        let q = A + d * u + m * c + p * l + b * a + v * f;
        A = q >>> 13, q &= 8191, q += B * (5 * x) + E * (5 * y) + I * (5 * w) + S * (5 * g) + O * (5 * h), A += q >>> 13, q &= 8191;
        let P = A + d * h + m * u + p * c + b * l + v * a;
        A = P >>> 13, P &= 8191, P += B * f + E * (5 * x) + I * (5 * y) + S * (5 * w) + O * (5 * g), A += P >>> 13, P &= 8191;
        let K = A + d * g + m * h + p * u + b * c + v * l;
        A = K >>> 13, K &= 8191, K += B * a + E * f + I * (5 * x) + S * (5 * y) + O * (5 * w), A += K >>> 13, K &= 8191;
        let et = A + d * w + m * g + p * h + b * u + v * c;
        A = et >>> 13, et &= 8191, et += B * l + E * a + I * f + S * (5 * x) + O * (5 * y), A += et >>> 13, et &= 8191;
        let Z = A + d * y + m * w + p * g + b * h + v * u;
        A = Z >>> 13, Z &= 8191, Z += B * c + E * l + I * a + S * f + O * (5 * x), A += Z >>> 13, Z &= 8191;
        let z = A + d * x + m * y + p * w + b * g + v * h;
        A = z >>> 13, z &= 8191, z += B * u + E * c + I * l + S * a + O * f, A += z >>> 13, z &= 8191, A = (A << 2) + A | 0, A = A + T | 0, T = A & 8191, A = A >>> 13, U += A, s[0] = T, s[1] = U, s[2] = C, s[3] = H, s[4] = q, s[5] = P, s[6] = K, s[7] = et, s[8] = Z, s[9] = z;
    }
    finalize() {
        const { h: e, pad: n } = this, r = new Uint16Array(10);
        let o = e[1] >>> 13;
        e[1] &= 8191;
        for(let f = 2; f < 10; f++)e[f] += o, o = e[f] >>> 13, e[f] &= 8191;
        e[0] += o * 5, o = e[0] >>> 13, e[0] &= 8191, e[1] += o, o = e[1] >>> 13, e[1] &= 8191, e[2] += o, r[0] = e[0] + 5, o = r[0] >>> 13, r[0] &= 8191;
        for(let f = 1; f < 10; f++)r[f] = e[f] + o, o = r[f] >>> 13, r[f] &= 8191;
        r[9] -= 8192;
        let s = (o ^ 1) - 1;
        for(let f = 0; f < 10; f++)r[f] &= s;
        s = ~s;
        for(let f = 0; f < 10; f++)e[f] = e[f] & s | r[f];
        e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
        let i = e[0] + n[0];
        e[0] = i & 65535;
        for(let f = 1; f < 8; f++)i = (e[f] + n[f] | 0) + (i >>> 16) | 0, e[f] = i & 65535;
        Wt(r);
    }
    update(e) {
        to(this), e = mn(e), nt(e);
        const { buffer: n, blockLen: r } = this, o = e.length;
        for(let s = 0; s < o;){
            const i = Math.min(r - this.pos, o - s);
            if (i === r) {
                for(; r <= o - s; s += r)this.process(e, s);
                continue;
            }
            n.set(e.subarray(s, s + i), this.pos), this.pos += i, s += i, this.pos === r && (this.process(n, 0, !1), this.pos = 0);
        }
        return this;
    }
    destroy() {
        Wt(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(e) {
        to(this), Sf(e, this), this.finished = !0;
        const { buffer: n, h: r } = this;
        let { pos: o } = this;
        if (o) {
            for(n[o++] = 1; o < 16; o++)n[o] = 0;
            this.process(n, 0, !0);
        }
        this.finalize();
        let s = 0;
        for(let i = 0; i < 8; i++)e[s++] = r[i] >>> 0, e[s++] = r[i] >>> 8;
        return e;
    }
    digest() {
        const { buffer: e, outputLen: n } = this;
        this.digestInto(e);
        const r = e.slice(0, n);
        return this.destroy(), r;
    }
    constructor(e){
        this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = mn(e), nt(e, 32);
        const n = G(e, 0), r = G(e, 2), o = G(e, 4), s = G(e, 6), i = G(e, 8), f = G(e, 10), a = G(e, 12), l = G(e, 14);
        this.r[0] = n & 8191, this.r[1] = (n >>> 13 | r << 3) & 8191, this.r[2] = (r >>> 10 | o << 6) & 7939, this.r[3] = (o >>> 7 | s << 9) & 8191, this.r[4] = (s >>> 4 | i << 12) & 255, this.r[5] = i >>> 1 & 8190, this.r[6] = (i >>> 14 | f << 2) & 8191, this.r[7] = (f >>> 11 | a << 5) & 8065, this.r[8] = (a >>> 8 | l << 8) & 8191, this.r[9] = l >>> 5 & 127;
        for(let c = 0; c < 8; c++)this.pad[c] = G(e, 16 + 2 * c);
    }
}
function qf(t) {
    const e = (r, o)=>t(o).update(mn(r)).digest(), n = t(new Uint8Array(32));
    return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = (r)=>t(r), e;
}
const Kf = qf((t)=>new Vf(t));
function Ff(t, e, n, r, o) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 20;
    let i = t[0], f = t[1], a = t[2], l = t[3], c = e[0], u = e[1], h = e[2], g = e[3], w = e[4], y = e[5], x = e[6], R = e[7], M = o, L = n[0], V = n[1], _ = n[2], k = i, j = f, $ = a, d = l, m = c, p = u, b = h, v = g, B = w, E = y, I = x, S = R, O = M, A = L, T = V, U = _;
    for(let H = 0; H < s; H += 2)k = k + m | 0, O = D(O ^ k, 16), B = B + O | 0, m = D(m ^ B, 12), k = k + m | 0, O = D(O ^ k, 8), B = B + O | 0, m = D(m ^ B, 7), j = j + p | 0, A = D(A ^ j, 16), E = E + A | 0, p = D(p ^ E, 12), j = j + p | 0, A = D(A ^ j, 8), E = E + A | 0, p = D(p ^ E, 7), $ = $ + b | 0, T = D(T ^ $, 16), I = I + T | 0, b = D(b ^ I, 12), $ = $ + b | 0, T = D(T ^ $, 8), I = I + T | 0, b = D(b ^ I, 7), d = d + v | 0, U = D(U ^ d, 16), S = S + U | 0, v = D(v ^ S, 12), d = d + v | 0, U = D(U ^ d, 8), S = S + U | 0, v = D(v ^ S, 7), k = k + p | 0, U = D(U ^ k, 16), I = I + U | 0, p = D(p ^ I, 12), k = k + p | 0, U = D(U ^ k, 8), I = I + U | 0, p = D(p ^ I, 7), j = j + b | 0, O = D(O ^ j, 16), S = S + O | 0, b = D(b ^ S, 12), j = j + b | 0, O = D(O ^ j, 8), S = S + O | 0, b = D(b ^ S, 7), $ = $ + v | 0, A = D(A ^ $, 16), B = B + A | 0, v = D(v ^ B, 12), $ = $ + v | 0, A = D(A ^ $, 8), B = B + A | 0, v = D(v ^ B, 7), d = d + m | 0, T = D(T ^ d, 16), E = E + T | 0, m = D(m ^ E, 12), d = d + m | 0, T = D(T ^ d, 8), E = E + T | 0, m = D(m ^ E, 7);
    let C = 0;
    r[C++] = i + k | 0, r[C++] = f + j | 0, r[C++] = a + $ | 0, r[C++] = l + d | 0, r[C++] = c + m | 0, r[C++] = u + p | 0, r[C++] = h + b | 0, r[C++] = g + v | 0, r[C++] = w + B | 0, r[C++] = y + E | 0, r[C++] = x + I | 0, r[C++] = R + S | 0, r[C++] = M + O | 0, r[C++] = L + A | 0, r[C++] = V + T | 0, r[C++] = _ + U | 0;
}
const zf = Mf(Ff, {
    counterRight: !1,
    counterLength: 4,
    allowShortKeys: !1
}), Gf = new Uint8Array(16), io = (t, e)=>{
    t.update(e);
    const n = e.length % 16;
    n && t.update(Gf.subarray(n));
}, Zf = new Uint8Array(32);
function fo(t, e, n, r, o) {
    const s = t(e, n, Zf), i = Kf.create(s);
    o && io(i, o), io(i, r);
    const f = $f(r.length, o ? o.length : 0, !0);
    i.update(f);
    const a = i.digest();
    return Wt(s, f), a;
}
const Wf = (t)=>(e, n, r)=>({
            encrypt (s, i) {
                const f = s.length;
                i = eo(f + 16, i, !1), i.set(s);
                const a = i.subarray(0, -16);
                t(e, n, a, a, 1);
                const l = fo(t, e, n, a, r);
                return i.set(l, f), Wt(l), i;
            },
            decrypt (s, i) {
                i = eo(s.length - 16, i, !1);
                const f = s.subarray(0, -16), a = s.subarray(-16), l = fo(t, e, n, f, r);
                if (!Tf(a, l)) throw new Error("invalid tag");
                return i.set(s.subarray(0, -16)), t(e, n, i, i, 1), Wt(l), i;
            }
        }), co = Rf({
    blockSize: 64,
    nonceLength: 12,
    tagLength: 16
}, Wf(zf));
class ao extends Ie {
    update(e) {
        return Nt(this), this.iHash.update(e), this;
    }
    digestInto(e) {
        Nt(this), at(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
    }
    digest() {
        const e = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(e), e;
    }
    _cloneInto(e) {
        e || (e = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash: n, iHash: r, finished: o, destroyed: s, blockLen: i, outputLen: f } = this;
        return e = e, e.finished = o, e.destroyed = s, e.blockLen = i, e.outputLen = f, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
    constructor(e, n){
        super(), this.finished = !1, this.destroyed = !1, rn(e);
        const r = ht(n);
        if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const o = this.blockLen, s = new Uint8Array(o);
        s.set(r.length > o ? e.create().update(r).digest() : r);
        for(let i = 0; i < s.length; i++)s[i] ^= 54;
        this.iHash.update(s), this.oHash = e.create();
        for(let i = 0; i < s.length; i++)s[i] ^= 106;
        this.oHash.update(s), ut(s);
    }
}
const _e = (t, e, n)=>new ao(t, e).update(n).digest();
_e.create = (t, e)=>new ao(t, e);
function Yf(t, e, n) {
    return rn(t), n === void 0 && (n = new Uint8Array(t.outputLen)), _e(t, ht(n), ht(e));
}
const vn = Uint8Array.from([
    0
]), uo = Uint8Array.of();
function Xf(t, e, n) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 32;
    rn(t), mt(r);
    const o = t.outputLen;
    if (r > 255 * o) throw new Error("Length should be <= 255*HashLen");
    const s = Math.ceil(r / o);
    n === void 0 && (n = uo);
    const i = new Uint8Array(s * o), f = _e.create(t, e), a = f._cloneInto(), l = new Uint8Array(f.outputLen);
    for(let c = 0; c < s; c++)vn[0] = c + 1, a.update(c === 0 ? uo : l).update(n).update(vn).digestInto(l), i.set(l, o * c), f._cloneInto(a);
    return f.destroy(), a.destroy(), ut(l, vn), i.slice(0, r);
}
const Jf = (t, e, n, r, o)=>Xf(t, Yf(t, e, n), r, o), Te = Ae, En = BigInt(0), Bn = BigInt(1);
function Re(t, e) {
    if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
function $e(t) {
    const e = t.toString(16);
    return e.length & 1 ? "0" + e : e;
}
function lo(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return t === "" ? En : BigInt("0x" + t);
}
function Ce(t) {
    return lo(ce(t));
}
function Le(t) {
    return at(t), lo(ce(Uint8Array.from(t).reverse()));
}
function In(t, e) {
    return fn(t.toString(16).padStart(e * 2, "0"));
}
function An(t, e) {
    return In(t, e).reverse();
}
function rt(t, e, n) {
    let r;
    if (typeof e == "string") try {
        r = fn(e);
    } catch (s) {
        throw new Error(t + " must be hex string or Uint8Array, cause: " + s);
    }
    else if (nn(e)) r = Uint8Array.from(e);
    else throw new Error(t + " must be hex string or Uint8Array");
    const o = r.length;
    if (typeof n == "number" && o !== n) throw new Error(t + " of length " + n + " expected, got " + o);
    return r;
}
const Sn = (t)=>typeof t == "bigint" && En <= t;
function Qf(t, e, n) {
    return Sn(t) && Sn(e) && Sn(n) && e <= t && t < n;
}
function Nn(t, e, n, r) {
    if (!Qf(e, n, r)) throw new Error("expected valid " + t + ": " + n + " <= n < " + r + ", got " + e);
}
function tc(t) {
    let e;
    for(e = 0; t > En; t >>= Bn, e += 1);
    return e;
}
const je = (t)=>(Bn << BigInt(t)) - Bn;
function ec(t, e, n) {
    if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof n != "function") throw new Error("hmacFn must be a function");
    const r = (g)=>new Uint8Array(g), o = (g)=>Uint8Array.of(g);
    let s = r(t), i = r(t), f = 0;
    const a = ()=>{
        s.fill(1), i.fill(0), f = 0;
    }, l = function() {
        for(var _len = arguments.length, g = new Array(_len), _key = 0; _key < _len; _key++){
            g[_key] = arguments[_key];
        }
        return n(i, s, ...g);
    }, c = function() {
        let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r(0);
        i = l(o(0), g), s = l(), g.length !== 0 && (i = l(o(1), g), s = l());
    }, u = ()=>{
        if (f++ >= 1e3) throw new Error("drbg: tried 1000 values");
        let g = 0;
        const w = [];
        for(; g < e;){
            s = l();
            const y = s.slice();
            w.push(y), g += s.length;
        }
        return Ht(...w);
    };
    return (g, w)=>{
        a(), c(g);
        let y;
        for(; !(y = w(u()));)c();
        return a(), y;
    };
}
function ke(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!t || typeof t != "object") throw new Error("expected valid options object");
    function r(o, s, i) {
        const f = t[o];
        if (i && f === void 0) return;
        const a = typeof f;
        if (a !== s || f === null) throw new Error('param "'.concat(o, '" is invalid: expected ').concat(s, ", got ").concat(a));
    }
    Object.entries(e).forEach((param)=>{
        let [o, s] = param;
        return r(o, s, !1);
    }), Object.entries(n).forEach((param)=>{
        let [o, s] = param;
        return r(o, s, !0);
    });
}
function ho(t) {
    const e = new WeakMap;
    return function(n) {
        for(var _len = arguments.length, r = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            r[_key - 1] = arguments[_key];
        }
        const o = e.get(n);
        if (o !== void 0) return o;
        const s = t(n, ...r);
        return e.set(n, s), s;
    };
}
const ot = BigInt(0), Q = BigInt(1), Dt = BigInt(2), nc = BigInt(3), po = BigInt(4), go = BigInt(5), bo = BigInt(8);
function lt(t, e) {
    const n = t % e;
    return n >= ot ? n : e + n;
}
function pt(t, e, n) {
    let r = t;
    for(; e-- > ot;)r *= r, r %= n;
    return r;
}
function yo(t, e) {
    if (t === ot) throw new Error("invert: expected non-zero number");
    if (e <= ot) throw new Error("invert: expected positive modulus, got " + e);
    let n = lt(t, e), r = e, o = ot, s = Q;
    for(; n !== ot;){
        const f = r / n, a = r % n, l = o - s * f;
        r = n, n = a, o = s, s = l;
    }
    if (r !== Q) throw new Error("invert: does not exist");
    return lt(o, e);
}
function mo(t, e) {
    const n = (t.ORDER + Q) / po, r = t.pow(e, n);
    if (!t.eql(t.sqr(r), e)) throw new Error("Cannot find square root");
    return r;
}
function rc(t, e) {
    const n = (t.ORDER - go) / bo, r = t.mul(e, Dt), o = t.pow(r, n), s = t.mul(e, o), i = t.mul(t.mul(s, Dt), o), f = t.mul(s, t.sub(i, t.ONE));
    if (!t.eql(t.sqr(f), e)) throw new Error("Cannot find square root");
    return f;
}
function oc(t) {
    if (t < BigInt(3)) throw new Error("sqrt is not defined for small field");
    let e = t - Q, n = 0;
    for(; e % Dt === ot;)e /= Dt, n++;
    let r = Dt;
    const o = Yt(t);
    for(; xo(o, r) === 1;)if (r++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
    if (n === 1) return mo;
    let s = o.pow(r, e);
    const i = (e + Q) / Dt;
    return function(a, l) {
        if (a.is0(l)) return l;
        if (xo(a, l) !== 1) throw new Error("Cannot find square root");
        let c = n, u = a.mul(a.ONE, s), h = a.pow(l, e), g = a.pow(l, i);
        for(; !a.eql(h, a.ONE);){
            if (a.is0(h)) return a.ZERO;
            let w = 1, y = a.sqr(h);
            for(; !a.eql(y, a.ONE);)if (w++, y = a.sqr(y), w === c) throw new Error("Cannot find square root");
            const x = Q << BigInt(c - w - 1), R = a.pow(u, x);
            c = w, u = a.sqr(R), h = a.mul(h, u), g = a.mul(g, R);
        }
        return g;
    };
}
function sc(t) {
    return t % po === nc ? mo : t % bo === go ? rc : oc(t);
}
const ic = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
];
function fc(t) {
    const e = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
    }, n = ic.reduce((r, o)=>(r[o] = "function", r), e);
    return ke(t, n), t;
}
function cc(t, e, n) {
    if (n < ot) throw new Error("invalid exponent, negatives unsupported");
    if (n === ot) return t.ONE;
    if (n === Q) return e;
    let r = t.ONE, o = e;
    for(; n > ot;)n & Q && (r = t.mul(r, o)), o = t.sqr(o), n >>= Q;
    return r;
}
function wo(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const r = new Array(e.length).fill(n ? t.ZERO : void 0), o = e.reduce((i, f, a)=>t.is0(f) ? i : (r[a] = i, t.mul(i, f)), t.ONE), s = t.inv(o);
    return e.reduceRight((i, f, a)=>t.is0(f) ? i : (r[a] = t.mul(i, r[a]), t.mul(i, f)), s), r;
}
function xo(t, e) {
    const n = (t.ORDER - Q) / Dt, r = t.pow(e, n), o = t.eql(r, t.ONE), s = t.eql(r, t.ZERO), i = t.eql(r, t.neg(t.ONE));
    if (!o && !s && !i) throw new Error("invalid Legendre symbol result");
    return o ? 1 : s ? 0 : -1;
}
function ac(t, e) {
    e !== void 0 && mt(e);
    const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
    return {
        nBitLength: n,
        nByteLength: r
    };
}
function Yt(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (t <= ot) throw new Error("invalid field: expected ORDER > 0, got " + t);
    let o, s;
    if (typeof e == "object" && e != null) {
        if (r.sqrt || n) throw new Error("cannot specify opts in two arguments");
        const c = e;
        c.BITS && (o = c.BITS), c.sqrt && (s = c.sqrt), typeof c.isLE == "boolean" && (n = c.isLE);
    } else typeof e == "number" && (o = e), r.sqrt && (s = r.sqrt);
    const { nBitLength: i, nByteLength: f } = ac(t, o);
    if (f > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let a;
    const l = Object.freeze({
        ORDER: t,
        isLE: n,
        BITS: i,
        BYTES: f,
        MASK: je(i),
        ZERO: ot,
        ONE: Q,
        create: (c)=>lt(c, t),
        isValid: (c)=>{
            if (typeof c != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof c);
            return ot <= c && c < t;
        },
        is0: (c)=>c === ot,
        isValidNot0: (c)=>!l.is0(c) && l.isValid(c),
        isOdd: (c)=>(c & Q) === Q,
        neg: (c)=>lt(-c, t),
        eql: (c, u)=>c === u,
        sqr: (c)=>lt(c * c, t),
        add: (c, u)=>lt(c + u, t),
        sub: (c, u)=>lt(c - u, t),
        mul: (c, u)=>lt(c * u, t),
        pow: (c, u)=>cc(l, c, u),
        div: (c, u)=>lt(c * yo(u, t), t),
        sqrN: (c)=>c * c,
        addN: (c, u)=>c + u,
        subN: (c, u)=>c - u,
        mulN: (c, u)=>c * u,
        inv: (c)=>yo(c, t),
        sqrt: s || ((c)=>(a || (a = sc(t)), a(l, c))),
        toBytes: (c)=>n ? An(c, f) : In(c, f),
        fromBytes: (c)=>{
            if (c.length !== f) throw new Error("Field.fromBytes: expected " + f + " bytes, got " + c.length);
            return n ? Le(c) : Ce(c);
        },
        invertBatch: (c)=>wo(l, c),
        cmov: (c, u, h)=>h ? u : c
    });
    return Object.freeze(l);
}
function vo(t) {
    if (typeof t != "bigint") throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8);
}
function Eo(t) {
    const e = vo(t);
    return e + Math.ceil(e / 2);
}
function uc(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const r = t.length, o = vo(e), s = Eo(e);
    if (r < 16 || r < s || r > 1024) throw new Error("expected " + s + "-1024 bytes of input, got " + r);
    const i = n ? Le(t) : Ce(t), f = lt(i, e - Q) + Q;
    return n ? An(f, o) : In(f, o);
}
const Xt = BigInt(0), Mt = BigInt(1);
function le(t, e) {
    const n = e.negate();
    return t ? n : e;
}
function lc(t, e, n) {
    const r = e === "pz" ? (i)=>i.pz : (i)=>i.ez, o = wo(t.Fp, n.map(r));
    return n.map((i, f)=>i.toAffine(o[f])).map(t.fromAffine);
}
function Bo(t, e) {
    if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function On(t, e) {
    Bo(t, e);
    const n = Math.ceil(e / t) + 1, r = 2 ** (t - 1), o = 2 ** t, s = je(t), i = BigInt(t);
    return {
        windows: n,
        windowSize: r,
        mask: s,
        maxNumber: o,
        shiftBy: i
    };
}
function Io(t, e, n) {
    const { windowSize: r, mask: o, maxNumber: s, shiftBy: i } = n;
    let f = Number(t & o), a = t >> i;
    f > r && (f -= s, a += Mt);
    const l = e * r, c = l + Math.abs(f) - 1, u = f === 0, h = f < 0, g = e % 2 !== 0;
    return {
        nextN: a,
        offset: c,
        isZero: u,
        isNeg: h,
        isNegF: g,
        offsetF: l
    };
}
function dc(t, e) {
    if (!Array.isArray(t)) throw new Error("array expected");
    t.forEach((n, r)=>{
        if (!(n instanceof e)) throw new Error("invalid point at index " + r);
    });
}
function hc(t, e) {
    if (!Array.isArray(t)) throw new Error("array of scalars expected");
    t.forEach((n, r)=>{
        if (!e.isValid(n)) throw new Error("invalid scalar at index " + r);
    });
}
const Un = new WeakMap, Ao = new WeakMap;
function _n(t) {
    return Ao.get(t) || 1;
}
function So(t) {
    if (t !== Xt) throw new Error("invalid wNAF");
}
function pc(t, e) {
    return {
        constTimeNegate: le,
        hasPrecomputes (n) {
            return _n(n) !== 1;
        },
        unsafeLadder (n, r) {
            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : t.ZERO;
            let s = n;
            for(; r > Xt;)r & Mt && (o = o.add(s)), s = s.double(), r >>= Mt;
            return o;
        },
        precomputeWindow (n, r) {
            const { windows: o, windowSize: s } = On(r, e), i = [];
            let f = n, a = f;
            for(let l = 0; l < o; l++){
                a = f, i.push(a);
                for(let c = 1; c < s; c++)a = a.add(f), i.push(a);
                f = a.double();
            }
            return i;
        },
        wNAF (n, r, o) {
            let s = t.ZERO, i = t.BASE;
            const f = On(n, e);
            for(let a = 0; a < f.windows; a++){
                const { nextN: l, offset: c, isZero: u, isNeg: h, isNegF: g, offsetF: w } = Io(o, a, f);
                o = l, u ? i = i.add(le(g, r[w])) : s = s.add(le(h, r[c]));
            }
            return So(o), {
                p: s,
                f: i
            };
        },
        wNAFUnsafe (n, r, o) {
            let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : t.ZERO;
            const i = On(n, e);
            for(let f = 0; f < i.windows && o !== Xt; f++){
                const { nextN: a, offset: l, isZero: c, isNeg: u } = Io(o, f, i);
                if (o = a, !c) {
                    const h = r[l];
                    s = s.add(u ? h.negate() : h);
                }
            }
            return So(o), s;
        },
        getPrecomputes (n, r, o) {
            let s = Un.get(r);
            return s || (s = this.precomputeWindow(r, n), n !== 1 && (typeof o == "function" && (s = o(s)), Un.set(r, s))), s;
        },
        wNAFCached (n, r, o) {
            const s = _n(n);
            return this.wNAF(s, this.getPrecomputes(s, n, o), r);
        },
        wNAFCachedUnsafe (n, r, o, s) {
            const i = _n(n);
            return i === 1 ? this.unsafeLadder(n, r, s) : this.wNAFUnsafe(i, this.getPrecomputes(i, n, o), r, s);
        },
        setWindowSize (n, r) {
            Bo(r, e), Ao.set(n, r), Un.delete(n);
        }
    };
}
function gc(t, e, n, r) {
    let o = e, s = t.ZERO, i = t.ZERO;
    for(; n > Xt || r > Xt;)n & Mt && (s = s.add(o)), r & Mt && (i = i.add(o)), o = o.double(), n >>= Mt, r >>= Mt;
    return {
        p1: s,
        p2: i
    };
}
function bc(t, e, n, r) {
    dc(n, t), hc(r, e);
    const o = n.length, s = r.length;
    if (o !== s) throw new Error("arrays of points and scalars must have equal length");
    const i = t.ZERO, f = tc(BigInt(o));
    let a = 1;
    f > 12 ? a = f - 3 : f > 4 ? a = f - 2 : f > 0 && (a = 2);
    const l = je(a), c = new Array(Number(l) + 1).fill(i), u = Math.floor((e.BITS - 1) / a) * a;
    let h = i;
    for(let g = u; g >= 0; g -= a){
        c.fill(i);
        for(let y = 0; y < s; y++){
            const x = r[y], R = Number(x >> BigInt(g) & l);
            c[R] = c[R].add(n[y]);
        }
        let w = i;
        for(let y = c.length - 1, x = i; y > 0; y--)x = x.add(c[y]), w = w.add(x);
        if (h = h.add(w), g !== 0) for(let y = 0; y < a; y++)h = h.double();
    }
    return h;
}
function No(t, e) {
    if (e) {
        if (e.ORDER !== t) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        return fc(e), e;
    } else return Yt(t);
}
function yc(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e || typeof e != "object") throw new Error("expected valid ".concat(t, " CURVE object"));
    for (const f of [
        "p",
        "n",
        "h"
    ]){
        const a = e[f];
        if (!(typeof a == "bigint" && a > Xt)) throw new Error("CURVE.".concat(f, " must be positive bigint"));
    }
    const r = No(e.p, n.Fp), o = No(e.n, n.Fn), i = [
        "Gx",
        "Gy",
        "a",
        t === "weierstrass" ? "b" : "d"
    ];
    for (const f of i)if (!r.isValid(e[f])) throw new Error("CURVE.".concat(f, " must be valid field element of CURVE.Fp"));
    return {
        Fp: r,
        Fn: o
    };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
const de = BigInt(0), Jt = BigInt(1), Pe = BigInt(2);
function mc(t) {
    return ke(t, {
        adjustScalarBytes: "function",
        powPminus2: "function"
    }), Object.freeze({
        ...t
    });
}
function wc(t) {
    const e = mc(t), { P: n, type: r, adjustScalarBytes: o, powPminus2: s, randomBytes: i } = e, f = r === "x25519";
    if (!f && r !== "x448") throw new Error("invalid type");
    const a = i || Zt, l = f ? 255 : 448, c = f ? 32 : 56, u = BigInt(f ? 9 : 5), h = BigInt(f ? 121665 : 39081), g = f ? Pe ** BigInt(254) : Pe ** BigInt(447), w = f ? BigInt(8) * Pe ** BigInt(251) - Jt : BigInt(4) * Pe ** BigInt(445) - Jt, y = g + w + Jt, x = (d)=>lt(d, n), R = M(u);
    function M(d) {
        return An(x(d), c);
    }
    function L(d) {
        const m = rt("u coordinate", d, c);
        return f && (m[31] &= 127), x(Le(m));
    }
    function V(d) {
        return Le(o(rt("scalar", d, c)));
    }
    function _(d, m) {
        const p = $(L(m), V(d));
        if (p === de) throw new Error("invalid private or public key received");
        return M(p);
    }
    function k(d) {
        return _(d, R);
    }
    function j(d, m, p) {
        const b = x(d * (m - p));
        return m = x(m - b), p = x(p + b), {
            x_2: m,
            x_3: p
        };
    }
    function $(d, m) {
        Nn("u", d, de, n), Nn("scalar", m, g, y);
        const p = m, b = d;
        let v = Jt, B = de, E = d, I = Jt, S = de;
        for(let A = BigInt(l - 1); A >= de; A--){
            const T = p >> A & Jt;
            S ^= T, ({ x_2: v, x_3: E } = j(S, v, E)), ({ x_2: B, x_3: I } = j(S, B, I)), S = T;
            const U = v + B, C = x(U * U), H = v - B, q = x(H * H), P = C - q, K = E + I, et = E - I, Z = x(et * U), z = x(K * H), Ft = Z + z, yt = Z - z;
            E = x(Ft * Ft), I = x(b * x(yt * yt)), v = x(C * q), B = x(P * (C + x(h * P)));
        }
        ({ x_2: v, x_3: E } = j(S, v, E)), { x_2: B, x_3: I } = j(S, B, I);
        const O = s(B);
        return x(v * O);
    }
    return {
        scalarMult: _,
        scalarMultBase: k,
        getSharedSecret: (d, m)=>_(d, m),
        getPublicKey: (d)=>k(d),
        utils: {
            randomPrivateKey: ()=>a(c)
        },
        GuBytes: R.slice()
    };
}
BigInt(0);
const xc = BigInt(1), Oo = BigInt(2), vc = BigInt(3), Ec = BigInt(5), Bc = BigInt(8), Uo = {
    p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
    n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
    h: Bc,
    a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
    d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
    Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
    Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
};
function Ic(t) {
    const e = BigInt(10), n = BigInt(20), r = BigInt(40), o = BigInt(80), s = Uo.p, f = t * t % s * t % s, a = pt(f, Oo, s) * f % s, l = pt(a, xc, s) * t % s, c = pt(l, Ec, s) * l % s, u = pt(c, e, s) * c % s, h = pt(u, n, s) * u % s, g = pt(h, r, s) * h % s, w = pt(g, o, s) * g % s, y = pt(w, o, s) * g % s, x = pt(y, e, s) * c % s;
    return {
        pow_p_5_8: pt(x, Oo, s) * t % s,
        b2: f
    };
}
function Ac(t) {
    return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
const Tn = (()=>{
    const t = Uo.p;
    return wc({
        P: t,
        type: "x25519",
        powPminus2: (e)=>{
            const { pow_p_5_8: n, b2: r } = Ic(e);
            return lt(pt(n, vc, t) * r, t);
        },
        adjustScalarBytes: Ac
    });
})();
function _o(t) {
    t.lowS !== void 0 && Re("lowS", t.lowS), t.prehash !== void 0 && Re("prehash", t.prehash);
}
class Sc extends Error {
    constructor(e = ""){
        super(e);
    }
}
const vt = {
    Err: Sc,
    _tlv: {
        encode: (t, e)=>{
            const { Err: n } = vt;
            if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
            if (e.length & 1) throw new n("tlv.encode: unpadded data");
            const r = e.length / 2, o = $e(r);
            if (o.length / 2 & 128) throw new n("tlv.encode: long form length too big");
            const s = r > 127 ? $e(o.length / 2 | 128) : "";
            return $e(t) + s + o + e;
        },
        decode (t, e) {
            const { Err: n } = vt;
            let r = 0;
            if (t < 0 || t > 256) throw new n("tlv.encode: wrong tag");
            if (e.length < 2 || e[r++] !== t) throw new n("tlv.decode: wrong tlv");
            const o = e[r++], s = !!(o & 128);
            let i = 0;
            if (!s) i = o;
            else {
                const a = o & 127;
                if (!a) throw new n("tlv.decode(long): indefinite length not supported");
                if (a > 4) throw new n("tlv.decode(long): byte length is too big");
                const l = e.subarray(r, r + a);
                if (l.length !== a) throw new n("tlv.decode: length bytes not complete");
                if (l[0] === 0) throw new n("tlv.decode(long): zero leftmost byte");
                for (const c of l)i = i << 8 | c;
                if (r += a, i < 128) throw new n("tlv.decode(long): not minimal encoding");
            }
            const f = e.subarray(r, r + i);
            if (f.length !== i) throw new n("tlv.decode: wrong value length");
            return {
                v: f,
                l: e.subarray(r + i)
            };
        }
    },
    _int: {
        encode (t) {
            const { Err: e } = vt;
            if (t < he) throw new e("integer: negative integers are not allowed");
            let n = $e(t);
            if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
            return n;
        },
        decode (t) {
            const { Err: e } = vt;
            if (t[0] & 128) throw new e("invalid signature integer: negative");
            if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
            return Ce(t);
        }
    },
    toSig (t) {
        const { Err: e, _int: n, _tlv: r } = vt, o = rt("signature", t), { v: s, l: i } = r.decode(48, o);
        if (i.length) throw new e("invalid signature: left bytes after parsing");
        const { v: f, l: a } = r.decode(2, s), { v: l, l: c } = r.decode(2, a);
        if (c.length) throw new e("invalid signature: left bytes after parsing");
        return {
            r: n.decode(f),
            s: n.decode(l)
        };
    },
    hexFromSig (t) {
        const { _tlv: e, _int: n } = vt, r = e.encode(2, n.encode(t.r)), o = e.encode(2, n.encode(t.s)), s = r + o;
        return e.encode(48, s);
    }
}, he = BigInt(0), pe = BigInt(1), Nc = BigInt(2), He = BigInt(3), Oc = BigInt(4);
function Uc(t, e, n) {
    function r(o) {
        const s = t.sqr(o), i = t.mul(s, o);
        return t.add(t.add(i, t.mul(o, e)), n);
    }
    return r;
}
function To(t, e, n) {
    const { BYTES: r } = t;
    function o(s) {
        let i;
        if (typeof s == "bigint") i = s;
        else {
            let f = rt("private key", s);
            if (e) {
                if (!e.includes(f.length * 2)) throw new Error("invalid private key");
                const a = new Uint8Array(r);
                a.set(f, a.length - f.length), f = a;
            }
            try {
                i = t.fromBytes(f);
            } catch (e) {
                throw new Error("invalid private key: expected ui8a of size ".concat(r, ", got ").concat(typeof s));
            }
        }
        if (n && (i = t.create(i)), !t.isValidNot0(i)) throw new Error("invalid private key: out of range [1..N-1]");
        return i;
    }
    return o;
}
function _c(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { Fp: n, Fn: r } = yc("weierstrass", t, e), { h: o, n: s } = t;
    ke(e, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
    });
    const { endo: i } = e;
    if (i && (!n.is0(t.a) || typeof i.beta != "bigint" || typeof i.splitScalar != "function")) throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    function f() {
        if (!n.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function a($, d, m) {
        const { x: p, y: b } = d.toAffine(), v = n.toBytes(p);
        if (Re("isCompressed", m), m) {
            f();
            const B = !n.isOdd(b);
            return Ht(Ro(B), v);
        } else return Ht(Uint8Array.of(4), v, n.toBytes(b));
    }
    function l($) {
        at($);
        const d = n.BYTES, m = d + 1, p = 2 * d + 1, b = $.length, v = $[0], B = $.subarray(1);
        if (b === m && (v === 2 || v === 3)) {
            const E = n.fromBytes(B);
            if (!n.isValid(E)) throw new Error("bad point: is not on curve, wrong x");
            const I = h(E);
            let S;
            try {
                S = n.sqrt(I);
            } catch (T) {
                const U = T instanceof Error ? ": " + T.message : "";
                throw new Error("bad point: is not on curve, sqrt error" + U);
            }
            f();
            const O = n.isOdd(S);
            return (v & 1) === 1 !== O && (S = n.neg(S)), {
                x: E,
                y: S
            };
        } else if (b === p && v === 4) {
            const E = n.fromBytes(B.subarray(d * 0, d * 1)), I = n.fromBytes(B.subarray(d * 1, d * 2));
            if (!g(E, I)) throw new Error("bad point: is not on curve");
            return {
                x: E,
                y: I
            };
        } else throw new Error("bad point: got length ".concat(b, ", expected compressed=").concat(m, " or uncompressed=").concat(p));
    }
    const c = e.toBytes || a, u = e.fromBytes || l, h = Uc(n, t.a, t.b);
    function g($, d) {
        const m = n.sqr(d), p = h($);
        return n.eql(m, p);
    }
    if (!g(t.Gx, t.Gy)) throw new Error("bad curve params: generator point");
    const w = n.mul(n.pow(t.a, He), Oc), y = n.mul(n.sqr(t.b), BigInt(27));
    if (n.is0(n.add(w, y))) throw new Error("bad curve params: a or b");
    function x($, d) {
        let m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        if (!n.isValid(d) || m && n.is0(d)) throw new Error("bad point coordinate ".concat($));
        return d;
    }
    function R($) {
        if (!($ instanceof _)) throw new Error("ProjectivePoint expected");
    }
    const M = ho(($, d)=>{
        const { px: m, py: p, pz: b } = $;
        if (n.eql(b, n.ONE)) return {
            x: m,
            y: p
        };
        const v = $.is0();
        d == null && (d = v ? n.ONE : n.inv(b));
        const B = n.mul(m, d), E = n.mul(p, d), I = n.mul(b, d);
        if (v) return {
            x: n.ZERO,
            y: n.ZERO
        };
        if (!n.eql(I, n.ONE)) throw new Error("invZ was invalid");
        return {
            x: B,
            y: E
        };
    }), L = ho(($)=>{
        if ($.is0()) {
            if (e.allowInfinityPoint && !n.is0($.py)) return;
            throw new Error("bad point: ZERO");
        }
        const { x: d, y: m } = $.toAffine();
        if (!n.isValid(d) || !n.isValid(m)) throw new Error("bad point: x or y not field elements");
        if (!g(d, m)) throw new Error("bad point: equation left != right");
        if (!$.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
        return !0;
    });
    function V($, d, m, p, b) {
        return m = new _(n.mul(m.px, $), m.py, m.pz), d = le(p, d), m = le(b, m), d.add(m);
    }
    class _ {
        static fromAffine(d) {
            const { x: m, y: p } = d || {};
            if (!d || !n.isValid(m) || !n.isValid(p)) throw new Error("invalid affine point");
            if (d instanceof _) throw new Error("projective point not allowed");
            return n.is0(m) && n.is0(p) ? _.ZERO : new _(m, p, n.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        static normalizeZ(d) {
            return lc(_, "pz", d);
        }
        static fromBytes(d) {
            return at(d), _.fromHex(d);
        }
        static fromHex(d) {
            const m = _.fromAffine(u(rt("pointHex", d)));
            return m.assertValidity(), m;
        }
        static fromPrivateKey(d) {
            const m = To(r, e.allowedPrivateKeyLengths, e.wrapPrivateKey);
            return _.BASE.multiply(m(d));
        }
        static msm(d, m) {
            return bc(_, r, d, m);
        }
        precompute() {
            let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
            return j.setWindowSize(this, d), m || this.multiply(He), this;
        }
        _setWindowSize(d) {
            this.precompute(d);
        }
        assertValidity() {
            L(this);
        }
        hasEvenY() {
            const { y: d } = this.toAffine();
            if (!n.isOdd) throw new Error("Field doesn't support isOdd");
            return !n.isOdd(d);
        }
        equals(d) {
            R(d);
            const { px: m, py: p, pz: b } = this, { px: v, py: B, pz: E } = d, I = n.eql(n.mul(m, E), n.mul(v, b)), S = n.eql(n.mul(p, E), n.mul(B, b));
            return I && S;
        }
        negate() {
            return new _(this.px, n.neg(this.py), this.pz);
        }
        double() {
            const { a: d, b: m } = t, p = n.mul(m, He), { px: b, py: v, pz: B } = this;
            let E = n.ZERO, I = n.ZERO, S = n.ZERO, O = n.mul(b, b), A = n.mul(v, v), T = n.mul(B, B), U = n.mul(b, v);
            return U = n.add(U, U), S = n.mul(b, B), S = n.add(S, S), E = n.mul(d, S), I = n.mul(p, T), I = n.add(E, I), E = n.sub(A, I), I = n.add(A, I), I = n.mul(E, I), E = n.mul(U, E), S = n.mul(p, S), T = n.mul(d, T), U = n.sub(O, T), U = n.mul(d, U), U = n.add(U, S), S = n.add(O, O), O = n.add(S, O), O = n.add(O, T), O = n.mul(O, U), I = n.add(I, O), T = n.mul(v, B), T = n.add(T, T), O = n.mul(T, U), E = n.sub(E, O), S = n.mul(T, A), S = n.add(S, S), S = n.add(S, S), new _(E, I, S);
        }
        add(d) {
            R(d);
            const { px: m, py: p, pz: b } = this, { px: v, py: B, pz: E } = d;
            let I = n.ZERO, S = n.ZERO, O = n.ZERO;
            const A = t.a, T = n.mul(t.b, He);
            let U = n.mul(m, v), C = n.mul(p, B), H = n.mul(b, E), q = n.add(m, p), P = n.add(v, B);
            q = n.mul(q, P), P = n.add(U, C), q = n.sub(q, P), P = n.add(m, b);
            let K = n.add(v, E);
            return P = n.mul(P, K), K = n.add(U, H), P = n.sub(P, K), K = n.add(p, b), I = n.add(B, E), K = n.mul(K, I), I = n.add(C, H), K = n.sub(K, I), O = n.mul(A, P), I = n.mul(T, H), O = n.add(I, O), I = n.sub(C, O), O = n.add(C, O), S = n.mul(I, O), C = n.add(U, U), C = n.add(C, U), H = n.mul(A, H), P = n.mul(T, P), C = n.add(C, H), H = n.sub(U, H), H = n.mul(A, H), P = n.add(P, H), U = n.mul(C, P), S = n.add(S, U), U = n.mul(K, P), I = n.mul(q, I), I = n.sub(I, U), U = n.mul(q, C), O = n.mul(K, O), O = n.add(O, U), new _(I, S, O);
        }
        subtract(d) {
            return this.add(d.negate());
        }
        is0() {
            return this.equals(_.ZERO);
        }
        multiply(d) {
            const { endo: m } = e;
            if (!r.isValidNot0(d)) throw new Error("invalid scalar: out of range");
            let p, b;
            const v = (B)=>j.wNAFCached(this, B, _.normalizeZ);
            if (m) {
                const { k1neg: B, k1: E, k2neg: I, k2: S } = m.splitScalar(d), { p: O, f: A } = v(E), { p: T, f: U } = v(S);
                b = A.add(U), p = V(m.beta, O, T, B, I);
            } else {
                const { p: B, f: E } = v(d);
                p = B, b = E;
            }
            return _.normalizeZ([
                p,
                b
            ])[0];
        }
        multiplyUnsafe(d) {
            const { endo: m } = e, p = this;
            if (!r.isValid(d)) throw new Error("invalid scalar: out of range");
            if (d === he || p.is0()) return _.ZERO;
            if (d === pe) return p;
            if (j.hasPrecomputes(this)) return this.multiply(d);
            if (m) {
                const { k1neg: b, k1: v, k2neg: B, k2: E } = m.splitScalar(d), { p1: I, p2: S } = gc(_, p, v, E);
                return V(m.beta, I, S, b, B);
            } else return j.wNAFCachedUnsafe(p, d);
        }
        multiplyAndAddUnsafe(d, m, p) {
            const b = this.multiplyUnsafe(m).add(d.multiplyUnsafe(p));
            return b.is0() ? void 0 : b;
        }
        toAffine(d) {
            return M(this, d);
        }
        isTorsionFree() {
            const { isTorsionFree: d } = e;
            return o === pe ? !0 : d ? d(_, this) : j.wNAFCachedUnsafe(this, s).is0();
        }
        clearCofactor() {
            const { clearCofactor: d } = e;
            return o === pe ? this : d ? d(_, this) : this.multiplyUnsafe(o);
        }
        toBytes() {
            let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            return Re("isCompressed", d), this.assertValidity(), c(_, this, d);
        }
        toRawBytes() {
            let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            return this.toBytes(d);
        }
        toHex() {
            let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            return ce(this.toBytes(d));
        }
        toString() {
            return "<Point ".concat(this.is0() ? "ZERO" : this.toHex(), ">");
        }
        constructor(d, m, p){
            this.px = x("x", d), this.py = x("y", m, !0), this.pz = x("z", p), Object.freeze(this);
        }
    }
    _.BASE = new _(t.Gx, t.Gy, n.ONE), _.ZERO = new _(n.ZERO, n.ONE, n.ZERO), _.Fp = n, _.Fn = r;
    const k = r.BITS, j = pc(_, e.endo ? Math.ceil(k / 2) : k);
    return _;
}
function Ro(t) {
    return Uint8Array.of(t ? 2 : 3);
}
function Tc(t, e) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    ke(e, {
        hash: "function"
    }, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
    });
    const r = e.randomBytes || Zt, o = e.hmac || function(p) {
        for(var _len = arguments.length, b = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            b[_key - 1] = arguments[_key];
        }
        return _e(e.hash, p, Ht(...b));
    }, { Fp: s, Fn: i } = t, { ORDER: f, BITS: a } = i;
    function l(p) {
        const b = f >> pe;
        return p > b;
    }
    function c(p) {
        return l(p) ? i.neg(p) : p;
    }
    function u(p, b) {
        if (!i.isValidNot0(b)) throw new Error("invalid signature ".concat(p, ": out of range 1..CURVE.n"));
    }
    class h {
        static fromCompact(b) {
            const v = i.BYTES, B = rt("compactSignature", b, v * 2);
            return new h(i.fromBytes(B.subarray(0, v)), i.fromBytes(B.subarray(v, v * 2)));
        }
        static fromDER(b) {
            const { r: v, s: B } = vt.toSig(rt("DER", b));
            return new h(v, B);
        }
        assertValidity() {}
        addRecoveryBit(b) {
            return new h(this.r, this.s, b);
        }
        recoverPublicKey(b) {
            const v = s.ORDER, { r: B, s: E, recovery: I } = this;
            if (I == null || ![
                0,
                1,
                2,
                3
            ].includes(I)) throw new Error("recovery id invalid");
            if (f * Nc < v && I > 1) throw new Error("recovery id is ambiguous for h>1 curve");
            const O = I === 2 || I === 3 ? B + f : B;
            if (!s.isValid(O)) throw new Error("recovery id 2 or 3 invalid");
            const A = s.toBytes(O), T = t.fromHex(Ht(Ro((I & 1) === 0), A)), U = i.inv(O), C = L(rt("msgHash", b)), H = i.create(-C * U), q = i.create(E * U), P = t.BASE.multiplyUnsafe(H).add(T.multiplyUnsafe(q));
            if (P.is0()) throw new Error("point at infinify");
            return P.assertValidity(), P;
        }
        hasHighS() {
            return l(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new h(this.r, i.neg(this.s), this.recovery) : this;
        }
        toBytes(b) {
            if (b === "compact") return Ht(i.toBytes(this.r), i.toBytes(this.s));
            if (b === "der") return fn(vt.hexFromSig(this));
            throw new Error("invalid format");
        }
        toDERRawBytes() {
            return this.toBytes("der");
        }
        toDERHex() {
            return ce(this.toBytes("der"));
        }
        toCompactRawBytes() {
            return this.toBytes("compact");
        }
        toCompactHex() {
            return ce(this.toBytes("compact"));
        }
        constructor(b, v, B){
            u("r", b), u("s", v), this.r = b, this.s = v, B != null && (this.recovery = B), Object.freeze(this);
        }
    }
    const g = To(i, n.allowedPrivateKeyLengths, n.wrapPrivateKey), w = {
        isValidPrivateKey (p) {
            try {
                return g(p), !0;
            } catch (e) {
                return !1;
            }
        },
        normPrivateKeyToScalar: g,
        randomPrivateKey: ()=>{
            const p = f;
            return uc(r(Eo(p)), p);
        },
        precompute () {
            let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.BASE;
            return b.precompute(p, !1);
        }
    };
    function y(p) {
        let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        return t.fromPrivateKey(p).toBytes(b);
    }
    function x(p) {
        if (typeof p == "bigint") return !1;
        if (p instanceof t) return !0;
        const v = rt("key", p).length, B = s.BYTES, E = B + 1, I = 2 * B + 1;
        if (!(n.allowedPrivateKeyLengths || i.BYTES === E)) return v === E || v === I;
    }
    function R(p, b) {
        let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
        if (x(p) === !0) throw new Error("first arg must be private key");
        if (x(b) === !1) throw new Error("second arg must be public key");
        return t.fromHex(b).multiply(g(p)).toBytes(v);
    }
    const M = e.bits2int || function(p) {
        if (p.length > 8192) throw new Error("input is too large");
        const b = Ce(p), v = p.length * 8 - a;
        return v > 0 ? b >> BigInt(v) : b;
    }, L = e.bits2int_modN || function(p) {
        return i.create(M(p));
    }, V = je(a);
    function _(p) {
        return Nn("num < 2^" + a, p, he, V), i.toBytes(p);
    }
    function k(p, b) {
        let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : j;
        if ([
            "recovered",
            "canonical"
        ].some((q)=>q in v)) throw new Error("sign() legacy options not supported");
        const { hash: B } = e;
        let { lowS: E, prehash: I, extraEntropy: S } = v;
        E == null && (E = !0), p = rt("msgHash", p), _o(v), I && (p = rt("prehashed msgHash", B(p)));
        const O = L(p), A = g(b), T = [
            _(A),
            _(O)
        ];
        if (S != null && S !== !1) {
            const q = S === !0 ? r(s.BYTES) : S;
            T.push(rt("extraEntropy", q));
        }
        const U = Ht(...T), C = O;
        function H(q) {
            const P = M(q);
            if (!i.isValidNot0(P)) return;
            const K = i.inv(P), et = t.BASE.multiply(P).toAffine(), Z = i.create(et.x);
            if (Z === he) return;
            const z = i.create(K * i.create(C + Z * A));
            if (z === he) return;
            let Ft = (et.x === Z ? 0 : 2) | Number(et.y & pe), yt = z;
            return E && l(z) && (yt = c(z), Ft ^= 1), new h(Z, yt, Ft);
        }
        return {
            seed: U,
            k2sig: H
        };
    }
    const j = {
        lowS: e.lowS,
        prehash: !1
    }, $ = {
        lowS: e.lowS,
        prehash: !1
    };
    function d(p, b) {
        let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : j;
        const { seed: B, k2sig: E } = k(p, b, v);
        return ec(e.hash.outputLen, i.BYTES, o)(B, E);
    }
    t.BASE.precompute(8);
    function m(p, b, v) {
        let B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : $;
        const E = p;
        b = rt("msgHash", b), v = rt("publicKey", v), _o(B);
        const { lowS: I, prehash: S, format: O } = B;
        if ("strict" in B) throw new Error("options.strict was renamed to lowS");
        if (O !== void 0 && ![
            "compact",
            "der",
            "js"
        ].includes(O)) throw new Error('format must be "compact", "der" or "js"');
        const A = typeof E == "string" || nn(E), T = !A && !O && typeof E == "object" && E !== null && typeof E.r == "bigint" && typeof E.s == "bigint";
        if (!A && !T) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let U, C;
        try {
            if (T) if (O === void 0 || O === "js") U = new h(E.r, E.s);
            else throw new Error("invalid format");
            if (A) {
                try {
                    O !== "compact" && (U = h.fromDER(E));
                } catch (yt) {
                    if (!(yt instanceof vt.Err)) throw yt;
                }
                !U && O !== "der" && (U = h.fromCompact(E));
            }
            C = t.fromHex(v);
        } catch (e) {
            return !1;
        }
        if (!U || I && U.hasHighS()) return !1;
        S && (b = e.hash(b));
        const { r: H, s: q } = U, P = L(b), K = i.inv(q), et = i.create(P * K), Z = i.create(H * K), z = t.BASE.multiplyUnsafe(et).add(C.multiplyUnsafe(Z));
        return z.is0() ? !1 : i.create(z.x) === H;
    }
    return Object.freeze({
        getPublicKey: y,
        getSharedSecret: R,
        sign: d,
        verify: m,
        utils: w,
        Point: t,
        Signature: h
    });
}
function Rc(t) {
    const e = {
        a: t.a,
        b: t.b,
        p: t.Fp.ORDER,
        n: t.n,
        h: t.h,
        Gx: t.Gx,
        Gy: t.Gy
    }, n = t.Fp, r = Yt(e.n, t.nBitLength), o = {
        Fp: n,
        Fn: r,
        allowedPrivateKeyLengths: t.allowedPrivateKeyLengths,
        allowInfinityPoint: t.allowInfinityPoint,
        endo: t.endo,
        wrapPrivateKey: t.wrapPrivateKey,
        isTorsionFree: t.isTorsionFree,
        clearCofactor: t.clearCofactor,
        fromBytes: t.fromBytes,
        toBytes: t.toBytes
    };
    return {
        CURVE: e,
        curveOpts: o
    };
}
function $c(t) {
    const { CURVE: e, curveOpts: n } = Rc(t), r = {
        hash: t.hash,
        hmac: t.hmac,
        randomBytes: t.randomBytes,
        lowS: t.lowS,
        bits2int: t.bits2int,
        bits2int_modN: t.bits2int_modN
    };
    return {
        CURVE: e,
        curveOpts: n,
        ecdsaOpts: r
    };
}
function Cc(t, e) {
    return Object.assign({}, e, {
        ProjectivePoint: e.Point,
        CURVE: t
    });
}
function Lc(t) {
    const { CURVE: e, curveOpts: n, ecdsaOpts: r } = $c(t), o = _c(e, n), s = Tc(o, r, n);
    return Cc(t, s);
}
function Rn(t, e) {
    const n = (r)=>Lc({
            ...t,
            hash: r
        });
    return {
        ...n(e),
        create: n
    };
}
const $o = {
    p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
    n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
    h: BigInt(1),
    a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
    b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
    Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
    Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
}, Co = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
    n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
    h: BigInt(1),
    a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
    b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
    Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
    Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
}, Lo = {
    p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
    h: BigInt(1),
    a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
    b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
    Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
    Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
}, jc = Yt($o.p), kc = Yt(Co.p), Pc = Yt(Lo.p), Hc = Rn({
    ...$o,
    Fp: jc,
    lowS: !1
}, Ae);
Rn({
    ...Co,
    Fp: kc,
    lowS: !1
}, Yi), Rn({
    ...Lo,
    Fp: Pc,
    lowS: !1,
    allowedPrivateKeyLengths: [
        130,
        131,
        132
    ]
}, Wi);
const Dc = Hc, $n = "base10", tt = "base16", Qt = "base64pad", De = "base64url", te = "utf8", Cn = 0, ee = 1, ge = 2, Mc = 0, jo = 1, be = 12, Ln = 32;
function Vc() {
    const t = Tn.utils.randomPrivateKey(), e = Tn.getPublicKey(t);
    return {
        privateKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(t, tt),
        publicKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(e, tt)
    };
}
function qc() {
    const t = Zt(Ln);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(t, tt);
}
function Kc(t, e) {
    const n = Tn.getSharedSecret((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t, tt), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(e, tt)), r = Jf(Te, n, void 0, void 0, Ln);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(r, tt);
}
function Fc(t) {
    const e = Te((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t, tt));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(e, tt);
}
function zc(t) {
    const e = Te((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t, te));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(e, tt);
}
function jn(t) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])("".concat(t), $n);
}
function Vt(t) {
    return Number((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(t, $n));
}
function ko(t) {
    return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Po(t) {
    const e = t.replace(/-/g, "+").replace(/_/g, "/"), n = (4 - e.length % 4) % 4;
    return e + "=".repeat(n);
}
function Gc(t) {
    const e = jn(typeof t.type < "u" ? t.type : Cn);
    if (Vt(e) === ee && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    const n = typeof t.senderPublicKey < "u" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t.senderPublicKey, tt) : void 0, r = typeof t.iv < "u" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t.iv, tt) : Zt(be), o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t.symKey, tt), s = co(o, r).encrypt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t.message, te)), i = kn({
        type: e,
        sealed: s,
        iv: r,
        senderPublicKey: n
    });
    return t.encoding === De ? ko(i) : i;
}
function Zc(t) {
    const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t.symKey, tt), { sealed: n, iv: r } = Me({
        encoded: t.encoded,
        encoding: t.encoding
    }), o = co(e, r).decrypt(n);
    if (o === null) throw new Error("Failed to decrypt");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(o, te);
}
function Wc(t, e) {
    const n = jn(ge), r = Zt(be), o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(t, te), s = kn({
        type: n,
        sealed: o,
        iv: r
    });
    return e === De ? ko(s) : s;
}
function Yc(t, e) {
    const { sealed: n } = Me({
        encoded: t,
        encoding: e
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(n, te);
}
function kn(t) {
    if (Vt(t.type) === ge) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        t.type,
        t.sealed
    ]), Qt);
    if (Vt(t.type) === ee) {
        if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
            t.type,
            t.senderPublicKey,
            t.iv,
            t.sealed
        ]), Qt);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        t.type,
        t.iv,
        t.sealed
    ]), Qt);
}
function Me(t) {
    const e = (t.encoding || Qt) === De ? Po(t.encoded) : t.encoded, n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(e, Qt), r = n.slice(Mc, jo), o = jo;
    if (Vt(r) === ee) {
        const a = o + Ln, l = a + be, c = n.slice(o, a), u = n.slice(a, l), h = n.slice(l);
        return {
            type: r,
            sealed: h,
            iv: u,
            senderPublicKey: c
        };
    }
    if (Vt(r) === ge) {
        const a = n.slice(o), l = Zt(be);
        return {
            type: r,
            sealed: a,
            iv: l
        };
    }
    const s = o + be, i = n.slice(o, s), f = n.slice(s);
    return {
        type: r,
        sealed: f,
        iv: i
    };
}
function Xc(t, e) {
    const n = Me({
        encoded: t,
        encoding: e === null || e === void 0 ? void 0 : e.encoding
    });
    return Ho({
        type: Vt(n.type),
        senderPublicKey: typeof n.senderPublicKey < "u" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(n.senderPublicKey, tt) : void 0,
        receiverPublicKey: e === null || e === void 0 ? void 0 : e.receiverPublicKey
    });
}
function Ho(t) {
    const e = (t === null || t === void 0 ? void 0 : t.type) || Cn;
    if (e === ee) {
        if (typeof (t === null || t === void 0 ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
        if (typeof (t === null || t === void 0 ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
    }
    return {
        type: e,
        senderPublicKey: t === null || t === void 0 ? void 0 : t.senderPublicKey,
        receiverPublicKey: t === null || t === void 0 ? void 0 : t.receiverPublicKey
    };
}
function Jc(t) {
    return t.type === ee && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Qc(t) {
    return t.type === ge;
}
function Do(t) {
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.x, "base64"), n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.y, "base64");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        new Uint8Array([
            4
        ]),
        e,
        n
    ]);
}
function ta(t, e) {
    const [n, r, o] = t.split("."), s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(Po(o), "base64");
    if (s.length !== 64) throw new Error("Invalid signature length");
    const i = s.slice(0, 32), f = s.slice(32, 64), a = "".concat(n, ".").concat(r), l = Te(a), c = Do(e);
    if (!Dc.verify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])([
        i,
        f
    ]), l, c)) throw new Error("Invalid signature");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$relay$2d$auth$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeJWT"])(t).payload;
}
const Mo = "irn";
function ea(t) {
    return (t === null || t === void 0 ? void 0 : t.relay) || {
        protocol: Mo
    };
}
function na(t) {
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$relay$2d$api$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RELAY_JSONRPC"][t];
    if (typeof e > "u") throw new Error("Relay Protocol not supported: ".concat(t));
    return e;
}
function Vo(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "-";
    const n = {}, r = "relay" + e;
    return Object.keys(t).forEach((o)=>{
        if (o.startsWith(r)) {
            const s = o.replace(r, ""), i = t[o];
            n[s] = i;
        }
    }), n;
}
function ra(t) {
    if (!t.includes("wc:")) {
        const l = Qe(t);
        l != null && l.includes("wc:") && (t = l);
    }
    t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
    const e = t.indexOf(":"), n = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r = t.substring(0, e), o = t.substring(e + 1, n).split("@"), s = typeof n < "u" ? t.substring(n) : "", i = new URLSearchParams(s), f = {};
    i.forEach((l, c)=>{
        f[c] = l;
    });
    const a = typeof f.methods == "string" ? f.methods.split(",") : void 0;
    return {
        protocol: r,
        topic: qo(o[0]),
        version: parseInt(o[1], 10),
        symKey: f.symKey,
        relay: Vo(f),
        methods: a,
        expiryTimestamp: f.expiryTimestamp ? parseInt(f.expiryTimestamp, 10) : void 0
    };
}
function qo(t) {
    return t.startsWith("//") ? t.substring(2) : t;
}
function Ko(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "-";
    const n = "relay", r = {};
    return Object.keys(t).forEach((o)=>{
        const s = o, i = n + e + s;
        t[s] && (r[i] = t[s]);
    }), r;
}
function oa(t) {
    const e = new URLSearchParams, n = Ko(t.relay);
    Object.keys(n).sort().forEach((o)=>{
        e.set(o, n[o]);
    }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
    const r = e.toString();
    return "".concat(t.protocol, ":").concat(t.topic, "@").concat(t.version, "?").concat(r);
}
function sa(t, e, n) {
    return "".concat(t, "?wc_ev=").concat(n, "&topic=").concat(e);
}
var ia = Object.defineProperty, fa = Object.defineProperties, ca = Object.getOwnPropertyDescriptors, Fo = Object.getOwnPropertySymbols, aa = Object.prototype.hasOwnProperty, ua = Object.prototype.propertyIsEnumerable, zo = (t, e, n)=>e in t ? ia(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: n
    }) : t[e] = n, la = (t, e)=>{
    for(var n in e || (e = {}))aa.call(e, n) && zo(t, n, e[n]);
    if (Fo) for (var n of Fo(e))ua.call(e, n) && zo(t, n, e[n]);
    return t;
}, da = (t, e)=>fa(t, ca(e));
function qt(t) {
    const e = [];
    return t.forEach((n)=>{
        const [r, o] = n.split(":");
        e.push("".concat(r, ":").concat(o));
    }), e;
}
function Go(t) {
    const e = [];
    return Object.values(t).forEach((n)=>{
        e.push(...qt(n.accounts));
    }), e;
}
function Zo(t, e) {
    const n = [];
    return Object.values(t).forEach((r)=>{
        qt(r.accounts).includes(e) && n.push(...r.methods);
    }), n;
}
function Wo(t, e) {
    const n = [];
    return Object.values(t).forEach((r)=>{
        qt(r.accounts).includes(e) && n.push(...r.events);
    }), n;
}
function ha(t, e) {
    const n = is(t, e);
    if (n) throw new Error(n.message);
    const r = {};
    for (const [o, s] of Object.entries(t))r[o] = {
        methods: s.methods,
        events: s.events,
        chains: s.accounts.map((i)=>"".concat(i.split(":")[0], ":").concat(i.split(":")[1]))
    };
    return r;
}
function pa(t) {
    var e;
    const { proposal: { requiredNamespaces: n, optionalNamespaces: r = {} }, supportedNamespaces: o } = t, s = ye(n), i = ye(r), f = {};
    Object.keys(o).forEach((c)=>{
        const u = o[c].chains, h = o[c].methods, g = o[c].events, w = o[c].accounts;
        u.forEach((y)=>{
            if (!w.some((x)=>x.includes(y))) throw new Error("No accounts provided for chain ".concat(y, " in namespace ").concat(c));
        }), f[c] = {
            chains: u,
            methods: h,
            events: g,
            accounts: w
        };
    });
    const a = cs(n, f, "approve()");
    if (a) throw new Error(a.message);
    const l = {};
    if (!Object.keys(n).length && !Object.keys(r).length) return f;
    Object.keys(s).forEach((c)=>{
        const u = o[c].chains.filter((y)=>{
            var x, R;
            return (R = (x = s[c]) == null ? void 0 : x.chains) == null ? void 0 : R.includes(y);
        }), h = o[c].methods.filter((y)=>{
            var x, R;
            return (R = (x = s[c]) == null ? void 0 : x.methods) == null ? void 0 : R.includes(y);
        }), g = o[c].events.filter((y)=>{
            var x, R;
            return (R = (x = s[c]) == null ? void 0 : x.events) == null ? void 0 : R.includes(y);
        }), w = u.map((y)=>o[c].accounts.filter((x)=>x.includes("".concat(y, ":")))).flat();
        l[c] = {
            chains: u,
            methods: h,
            events: g,
            accounts: w
        };
    }), Object.keys(i).forEach((c)=>{
        var u, h, g, w, y, x;
        if (!o[c]) return;
        const R = (h = (u = i[c]) == null ? void 0 : u.chains) == null ? void 0 : h.filter((_)=>o[c].chains.includes(_)), M = o[c].methods.filter((_)=>{
            var k, j;
            return (j = (k = i[c]) == null ? void 0 : k.methods) == null ? void 0 : j.includes(_);
        }), L = o[c].events.filter((_)=>{
            var k, j;
            return (j = (k = i[c]) == null ? void 0 : k.events) == null ? void 0 : j.includes(_);
        }), V = R === null || R === void 0 ? void 0 : R.map((_)=>o[c].accounts.filter((k)=>k.includes("".concat(_, ":")))).flat();
        l[c] = {
            chains: ct((g = l[c]) == null ? void 0 : g.chains, R),
            methods: ct((w = l[c]) == null ? void 0 : w.methods, M),
            events: ct((y = l[c]) == null ? void 0 : y.events, L),
            accounts: ct((x = l[c]) == null ? void 0 : x.accounts, V)
        };
    });
    for (const [c, u] of Object.entries(l))(u.accounts.length === 0 || ((e = u === null || u === void 0 ? void 0 : u.chains) == null ? void 0 : e.length) === 0) && delete l[c];
    return l;
}
function Pn(t) {
    return t.includes(":");
}
function Yo(t) {
    return Pn(t) ? t.split(":")[0] : t;
}
function ye(t) {
    var e, n, r;
    const o = {};
    if (!Ve(t)) return o;
    for (const [s, i] of Object.entries(t)){
        const f = Pn(s) ? [
            s
        ] : i.chains, a = i.methods || [], l = i.events || [], c = Yo(s);
        o[c] = da(la({}, o[c]), {
            chains: ct(f, (e = o[c]) == null ? void 0 : e.chains),
            methods: ct(a, (n = o[c]) == null ? void 0 : n.methods),
            events: ct(l, (r = o[c]) == null ? void 0 : r.events)
        });
    }
    return o;
}
function Xo(t) {
    const e = {};
    return t === null || t === void 0 ? void 0 : t.forEach((n)=>{
        var r;
        const [o, s] = n.split(":");
        e[o] || (e[o] = {
            accounts: [],
            chains: [],
            events: [],
            methods: []
        }), e[o].accounts.push(n), (r = e[o].chains) == null || r.push("".concat(o, ":").concat(s));
    }), e;
}
function ga(t, e) {
    e = e.map((r)=>r.replace("did:pkh:", ""));
    const n = Xo(e);
    for (const [r, o] of Object.entries(n))o.methods ? o.methods = ct(o.methods, t) : o.methods = t, o.events = [
        "chainChanged",
        "accountsChanged"
    ];
    return n;
}
function ba(t, e) {
    var n, r, o, s, i, f;
    const a = ye(t), l = ye(e), c = {}, u = Object.keys(a).concat(Object.keys(l));
    for (const h of u)c[h] = {
        chains: ct((n = a[h]) == null ? void 0 : n.chains, (r = l[h]) == null ? void 0 : r.chains),
        methods: ct((o = a[h]) == null ? void 0 : o.methods, (s = l[h]) == null ? void 0 : s.methods),
        events: ct((i = a[h]) == null ? void 0 : i.events, (f = l[h]) == null ? void 0 : f.events)
    };
    return c;
}
const Jo = {
    INVALID_METHOD: {
        message: "Invalid method.",
        code: 1001
    },
    INVALID_EVENT: {
        message: "Invalid event.",
        code: 1002
    },
    INVALID_UPDATE_REQUEST: {
        message: "Invalid update request.",
        code: 1003
    },
    INVALID_EXTEND_REQUEST: {
        message: "Invalid extend request.",
        code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
        message: "Invalid session settle request.",
        code: 1005
    },
    UNAUTHORIZED_METHOD: {
        message: "Unauthorized method.",
        code: 3001
    },
    UNAUTHORIZED_EVENT: {
        message: "Unauthorized event.",
        code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
        message: "Unauthorized update request.",
        code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
        message: "Unauthorized extend request.",
        code: 3004
    },
    USER_REJECTED: {
        message: "User rejected.",
        code: 5e3
    },
    USER_REJECTED_CHAINS: {
        message: "User rejected chains.",
        code: 5001
    },
    USER_REJECTED_METHODS: {
        message: "User rejected methods.",
        code: 5002
    },
    USER_REJECTED_EVENTS: {
        message: "User rejected events.",
        code: 5003
    },
    UNSUPPORTED_CHAINS: {
        message: "Unsupported chains.",
        code: 5100
    },
    UNSUPPORTED_METHODS: {
        message: "Unsupported methods.",
        code: 5101
    },
    UNSUPPORTED_EVENTS: {
        message: "Unsupported events.",
        code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
        message: "Unsupported accounts.",
        code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
        message: "Unsupported namespace key.",
        code: 5104
    },
    USER_DISCONNECTED: {
        message: "User disconnected.",
        code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
        message: "Session settlement failed.",
        code: 7e3
    },
    WC_METHOD_UNSUPPORTED: {
        message: "Unsupported wc_ method.",
        code: 10001
    }
}, Qo = {
    NOT_INITIALIZED: {
        message: "Not initialized.",
        code: 1
    },
    NO_MATCHING_KEY: {
        message: "No matching key.",
        code: 2
    },
    RESTORE_WILL_OVERRIDE: {
        message: "Restore will override.",
        code: 3
    },
    RESUBSCRIBED: {
        message: "Resubscribed.",
        code: 4
    },
    MISSING_OR_INVALID: {
        message: "Missing or invalid.",
        code: 5
    },
    EXPIRED: {
        message: "Expired.",
        code: 6
    },
    UNKNOWN_TYPE: {
        message: "Unknown type.",
        code: 7
    },
    MISMATCHED_TOPIC: {
        message: "Mismatched topic.",
        code: 8
    },
    NON_CONFORMING_NAMESPACES: {
        message: "Non conforming namespaces.",
        code: 9
    }
};
function Et(t, e) {
    const { message: n, code: r } = Qo[t];
    return {
        message: e ? "".concat(n, " ").concat(e) : n,
        code: r
    };
}
function Kt(t, e) {
    const { message: n, code: r } = Jo[t];
    return {
        message: e ? "".concat(n, " ").concat(e) : n,
        code: r
    };
}
function me(t, e) {
    return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : !0 : !1;
}
function Ve(t) {
    return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function kt(t) {
    return typeof t > "u";
}
function it(t, e) {
    return e && kt(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function qe(t, e) {
    return e && kt(t) ? !0 : typeof t == "number" && !isNaN(t);
}
function ya(t, e) {
    const { requiredNamespaces: n } = e, r = Object.keys(t.namespaces), o = Object.keys(n);
    let s = !0;
    return It(o, r) ? (r.forEach((i)=>{
        const { accounts: f, methods: a, events: l } = t.namespaces[i], c = qt(f), u = n[i];
        (!It(ve(i, u), c) || !It(u.methods, a) || !It(u.events, l)) && (s = !1);
    }), s) : !1;
}
function we(t) {
    return it(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function ts(t) {
    if (it(t, !1) && t.includes(":")) {
        const e = t.split(":");
        if (e.length === 3) {
            const n = e[0] + ":" + e[1];
            return !!e[2] && we(n);
        }
    }
    return !1;
}
function ma(t) {
    function e(n) {
        try {
            return typeof new URL(n) < "u";
        } catch (e) {
            return !1;
        }
    }
    try {
        if (it(t, !1)) {
            if (e(t)) return !0;
            const n = Qe(t);
            return e(n);
        }
    } catch (e) {}
    return !1;
}
function wa(t) {
    var e;
    return (e = t === null || t === void 0 ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function xa(t) {
    return t === null || t === void 0 ? void 0 : t.topic;
}
function va(t, e) {
    let n = null;
    return it(t === null || t === void 0 ? void 0 : t.publicKey, !1) || (n = Et("MISSING_OR_INVALID", "".concat(e, " controller public key should be a string"))), n;
}
function Hn(t) {
    let e = !0;
    return me(t) ? t.length && (e = t.every((n)=>it(n, !1))) : e = !1, e;
}
function es(t, e, n) {
    let r = null;
    return me(e) && e.length ? e.forEach((o)=>{
        r || we(o) || (r = Kt("UNSUPPORTED_CHAINS", "".concat(n, ", chain ").concat(o, ' should be a string and conform to "namespace:chainId" format')));
    }) : we(t) || (r = Kt("UNSUPPORTED_CHAINS", "".concat(n, ', chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }'))), r;
}
function ns(t, e, n) {
    let r = null;
    return Object.entries(t).forEach((param)=>{
        let [o, s] = param;
        if (r) return;
        const i = es(o, ve(o, s), "".concat(e, " ").concat(n));
        i && (r = i);
    }), r;
}
function rs(t, e) {
    let n = null;
    return me(t) ? t.forEach((r)=>{
        n || ts(r) || (n = Kt("UNSUPPORTED_ACCOUNTS", "".concat(e, ", account ").concat(r, ' should be a string and conform to "namespace:chainId:address" format')));
    }) : n = Kt("UNSUPPORTED_ACCOUNTS", "".concat(e, ', accounts should be an array of strings conforming to "namespace:chainId:address" format')), n;
}
function os(t, e) {
    let n = null;
    return Object.values(t).forEach((r)=>{
        if (n) return;
        const o = rs(r === null || r === void 0 ? void 0 : r.accounts, "".concat(e, " namespace"));
        o && (n = o);
    }), n;
}
function ss(t, e) {
    let n = null;
    return Hn(t === null || t === void 0 ? void 0 : t.methods) ? Hn(t === null || t === void 0 ? void 0 : t.events) || (n = Kt("UNSUPPORTED_EVENTS", "".concat(e, ", events should be an array of strings or empty array for no events"))) : n = Kt("UNSUPPORTED_METHODS", "".concat(e, ", methods should be an array of strings or empty array for no methods")), n;
}
function Dn(t, e) {
    let n = null;
    return Object.values(t).forEach((r)=>{
        if (n) return;
        const o = ss(r, "".concat(e, ", namespace"));
        o && (n = o);
    }), n;
}
function Ea(t, e, n) {
    let r = null;
    if (t && Ve(t)) {
        const o = Dn(t, e);
        o && (r = o);
        const s = ns(t, e, n);
        s && (r = s);
    } else r = Et("MISSING_OR_INVALID", "".concat(e, ", ").concat(n, " should be an object with data"));
    return r;
}
function is(t, e) {
    let n = null;
    if (t && Ve(t)) {
        const r = Dn(t, e);
        r && (n = r);
        const o = os(t, e);
        o && (n = o);
    } else n = Et("MISSING_OR_INVALID", "".concat(e, ", namespaces should be an object with data"));
    return n;
}
function fs(t) {
    return it(t.protocol, !0);
}
function Ba(t, e) {
    let n = !1;
    return e && !t ? n = !0 : t && me(t) && t.length && t.forEach((r)=>{
        n = fs(r);
    }), n;
}
function Ia(t) {
    return typeof t == "number";
}
function Aa(t) {
    return typeof t < "u" && typeof t !== null;
}
function Sa(t) {
    return !(!t || typeof t != "object" || !t.code || !qe(t.code, !1) || !t.message || !it(t.message, !1));
}
function Na(t) {
    return !(kt(t) || !it(t.method, !1));
}
function Oa(t) {
    return !(kt(t) || kt(t.result) && kt(t.error) || !qe(t.id, !1) || !it(t.jsonrpc, !1));
}
function Ua(t) {
    return !(kt(t) || !it(t.name, !1));
}
function _a(t, e) {
    return !(!we(e) || !Go(t).includes(e));
}
function Ta(t, e, n) {
    return it(n, !1) ? Zo(t, e).includes(n) : !1;
}
function Ra(t, e, n) {
    return it(n, !1) ? Wo(t, e).includes(n) : !1;
}
function cs(t, e, n) {
    let r = null;
    const o = $a(t), s = Ca(e), i = Object.keys(o), f = Object.keys(s), a = as(Object.keys(t)), l = as(Object.keys(e)), c = a.filter((u)=>!l.includes(u));
    return c.length && (r = Et("NON_CONFORMING_NAMESPACES", "".concat(n, " namespaces keys don't satisfy requiredNamespaces.\n      Required: ").concat(c.toString(), "\n      Received: ").concat(Object.keys(e).toString()))), It(i, f) || (r = Et("NON_CONFORMING_NAMESPACES", "".concat(n, " namespaces chains don't satisfy required namespaces.\n      Required: ").concat(i.toString(), "\n      Approved: ").concat(f.toString()))), Object.keys(e).forEach((u)=>{
        if (!u.includes(":") || r) return;
        const h = qt(e[u].accounts);
        h.includes(u) || (r = Et("NON_CONFORMING_NAMESPACES", "".concat(n, " namespaces accounts don't satisfy namespace accounts for ").concat(u, "\n        Required: ").concat(u, "\n        Approved: ").concat(h.toString())));
    }), i.forEach((u)=>{
        r || (It(o[u].methods, s[u].methods) ? It(o[u].events, s[u].events) || (r = Et("NON_CONFORMING_NAMESPACES", "".concat(n, " namespaces events don't satisfy namespace events for ").concat(u))) : r = Et("NON_CONFORMING_NAMESPACES", "".concat(n, " namespaces methods don't satisfy namespace methods for ").concat(u)));
    }), r;
}
function $a(t) {
    const e = {};
    return Object.keys(t).forEach((n)=>{
        var r;
        n.includes(":") ? e[n] = t[n] : (r = t[n].chains) == null || r.forEach((o)=>{
            e[o] = {
                methods: t[n].methods,
                events: t[n].events
            };
        });
    }), e;
}
function as(t) {
    return [
        ...new Set(t.map((e)=>e.includes(":") ? e.split(":")[0] : e))
    ];
}
function Ca(t) {
    const e = {};
    return Object.keys(t).forEach((n)=>{
        if (n.includes(":")) e[n] = t[n];
        else {
            const r = qt(t[n].accounts);
            r === null || r === void 0 ? void 0 : r.forEach((o)=>{
                e[o] = {
                    accounts: t[n].accounts.filter((s)=>s.includes("".concat(o, ":"))),
                    methods: t[n].methods,
                    events: t[n].events
                };
            });
        }
    }), e;
}
function La(t, e) {
    return qe(t, !1) && t <= e.max && t >= e.min;
}
function ja() {
    const t = Pt();
    return new Promise((e)=>{
        switch(t){
            case J.browser:
                e(us());
                break;
            case J.reactNative:
                e(ls());
                break;
            case J.node:
                e(ds());
                break;
            default:
                e(!0);
        }
    });
}
function us() {
    var _navigator;
    return zt() && ((_navigator = navigator) === null || _navigator === void 0 ? void 0 : _navigator.onLine);
}
async function ls() {
    if (Bt() && ("TURBOPACK compile-time value", "object") < "u" && ("TURBOPACK ident replacement", globalThis) != null && ("TURBOPACK ident replacement", globalThis).NetInfo) {
        const t = await (("TURBOPACK ident replacement", globalThis) == null ? void 0 : ("TURBOPACK ident replacement", globalThis).NetInfo.fetch());
        return t === null || t === void 0 ? void 0 : t.isConnected;
    }
    return !0;
}
function ds() {
    return !0;
}
function ka(t) {
    switch(Pt()){
        case J.browser:
            hs(t);
            break;
        case J.reactNative:
            ps(t);
            break;
        case J.node:
            break;
    }
}
function hs(t) {
    !Bt() && zt() && (window.addEventListener("online", ()=>t(!0)), window.addEventListener("offline", ()=>t(!1)));
}
function ps(t) {
    var _global;
    Bt() && ("TURBOPACK compile-time value", "object") < "u" && ("TURBOPACK ident replacement", globalThis) != null && ("TURBOPACK ident replacement", globalThis).NetInfo && ((_global = ("TURBOPACK ident replacement", globalThis)) === null || _global === void 0 ? void 0 : _global.NetInfo.addEventListener((e)=>t(e === null || e === void 0 ? void 0 : e.isConnected)));
}
function Pa() {
    var t;
    return zt() && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])() ? ((t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$window$2d$getters$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDocument"])()) == null ? void 0 : t.visibilityState) === "visible" : !0;
}
const Mn = {};
class Ha {
    static get(e) {
        return Mn[e];
    }
    static set(e, n) {
        Mn[e] = n;
    }
    static delete(e) {
        delete Mn[e];
    }
}
function gs(t) {
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(t);
    if (e.length < 33) throw new Error("Too short to contain a public key");
    return e.slice(1, 33);
}
function bs(param) {
    let { publicKey: t, signature: e, payload: n } = param;
    var r;
    const o = Vn(n.method), s = 128 | parseInt(((r = n.version) == null ? void 0 : r.toString()) || "4"), i = Ma(n.address), f = n.era === "00" ? new Uint8Array([
        0
    ]) : Vn(n.era);
    if (f.length !== 1 && f.length !== 2) throw new Error("Invalid era length");
    const a = parseInt(n.nonce, 16), l = new Uint8Array([
        a & 255,
        a >> 8 & 255
    ]), c = BigInt("0x".concat(Da(n.tip))), u = qa(c), h = new Uint8Array([
        0,
        ...t,
        i,
        ...e,
        ...f,
        ...l,
        ...u,
        ...o
    ]), g = Va(h.length + 1);
    return new Uint8Array([
        ...g,
        s,
        ...h
    ]);
}
function ys(t) {
    const e = Vn(t), n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$blakejs$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blake2b"])(e, void 0, 32);
    return "0x" + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(n).toString("hex");
}
function Vn(t) {
    return new Uint8Array(t.replace(/^0x/, "").match(/.{1,2}/g).map((e)=>parseInt(e, 16)));
}
function Da(t) {
    return t.startsWith("0x") ? t.slice(2) : t;
}
function Ma(t) {
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(t)[0];
    return e === 42 ? 0 : e === 60 ? 2 : 1;
}
function Va(t) {
    if (t < 64) return new Uint8Array([
        t << 2
    ]);
    if (t < 16384) {
        const e = t << 2 | 1;
        return new Uint8Array([
            e & 255,
            e >> 8 & 255
        ]);
    } else if (t < 1 << 30) {
        const e = t << 2 | 2;
        return new Uint8Array([
            e & 255,
            e >> 8 & 255,
            e >> 16 & 255,
            e >> 24 & 255
        ]);
    } else throw new Error("Compact encoding > 2^30 not supported");
}
function qa(t) {
    if (t < BigInt(1) << BigInt(6)) return new Uint8Array([
        Number(t << BigInt(2))
    ]);
    if (t < BigInt(1) << BigInt(14)) {
        const e = t << BigInt(2) | BigInt(1);
        return new Uint8Array([
            Number(e & BigInt(255)),
            Number(e >> BigInt(8) & BigInt(255))
        ]);
    } else if (t < BigInt(1) << BigInt(30)) {
        const e = t << BigInt(2) | BigInt(2);
        return new Uint8Array([
            Number(e & BigInt(255)),
            Number(e >> BigInt(8) & BigInt(255)),
            Number(e >> BigInt(16) & BigInt(255)),
            Number(e >> BigInt(24) & BigInt(255))
        ]);
    } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function Ka(t) {
    const e = Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(t.signature, "hex")), n = gs(t.transaction.address), r = bs({
        publicKey: n,
        signature: e,
        payload: t.transaction
    }), o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(r).toString("hex");
    return ys(o);
}
;
 //# sourceMappingURL=index.es.js.map
}),
"[project]/node_modules/@walletconnect/jsonrpc-http-connection/node_modules/cross-fetch/dist/browser-ponyfill.js [app-client] (ecmascript)": ((__turbopack_context__) => {

var { m: module, e: exports } = __turbopack_context__;
{
// Save global object in a variable
var __global__ = typeof globalThis !== 'undefined' && globalThis || typeof self !== 'undefined' && self || ("TURBOPACK compile-time value", "object") !== 'undefined' && ("TURBOPACK ident replacement", globalThis);
// Create an object that extends from __global__ without the fetch function
var __globalThis__ = function() {
    function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
    }
    F.prototype = __global__; // Needed for feature detection on whatwg-fetch's code
    return new F();
}();
// Wraps whatwg-fetch with a function scope to hijack the global object
// "globalThis" that's going to be patched
(function(globalThis1) {
    var irrelevant = function(exports1) {
        /* eslint-disable no-prototype-builtins */ var g = typeof globalThis1 !== 'undefined' && globalThis1 || typeof self !== 'undefined' && self || ("TURBOPACK compile-time value", "object") !== 'undefined' && ("TURBOPACK ident replacement", globalThis) || {};
        var support = {
            searchParams: 'URLSearchParams' in g,
            iterable: 'Symbol' in g && 'iterator' in Symbol,
            blob: 'FileReader' in g && 'Blob' in g && function() {
                try {
                    new Blob();
                    return true;
                } catch (e) {
                    return false;
                }
            }(),
            formData: 'FormData' in g,
            arrayBuffer: 'ArrayBuffer' in g
        };
        function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
            var viewClasses = [
                '[object Int8Array]',
                '[object Uint8Array]',
                '[object Uint8ClampedArray]',
                '[object Int16Array]',
                '[object Uint16Array]',
                '[object Int32Array]',
                '[object Uint32Array]',
                '[object Float32Array]',
                '[object Float64Array]'
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
        }
        function normalizeName(name) {
            if (typeof name !== 'string') {
                name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
                throw new TypeError('Invalid character in header field name: "' + name + '"');
            }
            return name.toLowerCase();
        }
        function normalizeValue(value) {
            if (typeof value !== 'string') {
                value = String(value);
            }
            return value;
        }
        // Build a destructive iterator for the value list
        function iteratorFor(items) {
            var iterator = {
                next: function() {
                    var value = items.shift();
                    return {
                        done: value === undefined,
                        value: value
                    };
                }
            };
            if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                    return iterator;
                };
            }
            return iterator;
        }
        function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                    this.append(name, value);
                }, this);
            } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                    if (header.length != 2) {
                        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length);
                    }
                    this.append(header[0], header[1]);
                }, this);
            } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                    this.append(name, headers[name]);
                }, this);
            }
        }
        Headers.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ', ' + value : value;
        };
        Headers.prototype['delete'] = function(name) {
            delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
            for(var name in this.map){
                if (this.map.hasOwnProperty(name)) {
                    callback.call(thisArg, this.map[name], name, this);
                }
            }
        };
        Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
                items.push(name);
            });
            return iteratorFor(items);
        };
        Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
                items.push(value);
            });
            return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
                items.push([
                    name,
                    value
                ]);
            });
            return iteratorFor(items);
        };
        if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
            if (body._noBody) return;
            if (body.bodyUsed) {
                return Promise.reject(new TypeError('Already read'));
            }
            body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
                reader.onload = function() {
                    resolve(reader.result);
                };
                reader.onerror = function() {
                    reject(reader.error);
                };
            });
        }
        function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
        }
        function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
            var encoding = match ? match[1] : 'utf-8';
            reader.readAsText(blob, encoding);
            return promise;
        }
        function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for(var i = 0; i < view.length; i++){
                chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join('');
        }
        function bufferClone(buf) {
            if (buf.slice) {
                return buf.slice(0);
            } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
            }
        }
        function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
                /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */ // eslint-disable-next-line no-self-assign
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;
                if (!body) {
                    this._noBody = true;
                    this._bodyText = '';
                } else if (typeof body === 'string') {
                    this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                    this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                    this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                    this._bodyArrayBuffer = bufferClone(body.buffer);
                    // IE 10-11 can't handle a DataView body.
                    this._bodyInit = new Blob([
                        this._bodyArrayBuffer
                    ]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                    this._bodyArrayBuffer = bufferClone(body);
                } else {
                    this._bodyText = body = Object.prototype.toString.call(body);
                }
                if (!this.headers.get('content-type')) {
                    if (typeof body === 'string') {
                        this.headers.set('content-type', 'text/plain;charset=UTF-8');
                    } else if (this._bodyBlob && this._bodyBlob.type) {
                        this.headers.set('content-type', this._bodyBlob.type);
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                    }
                }
            };
            if (support.blob) {
                this.blob = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                        return rejected;
                    }
                    if (this._bodyBlob) {
                        return Promise.resolve(this._bodyBlob);
                    } else if (this._bodyArrayBuffer) {
                        return Promise.resolve(new Blob([
                            this._bodyArrayBuffer
                        ]));
                    } else if (this._bodyFormData) {
                        throw new Error('could not read FormData body as blob');
                    } else {
                        return Promise.resolve(new Blob([
                            this._bodyText
                        ]));
                    }
                };
            }
            this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);
                    if (isConsumed) {
                        return isConsumed;
                    } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                        return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
                    } else {
                        return Promise.resolve(this._bodyArrayBuffer);
                    }
                } else if (support.blob) {
                    return this.blob().then(readBlobAsArrayBuffer);
                } else {
                    throw new Error('could not read as ArrayBuffer');
                }
            };
            this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                    return rejected;
                }
                if (this._bodyBlob) {
                    return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as text');
                } else {
                    return Promise.resolve(this._bodyText);
                }
            };
            if (support.formData) {
                this.formData = function() {
                    return this.text().then(decode);
                };
            }
            this.json = function() {
                return this.text().then(JSON.parse);
            };
            return this;
        }
        // HTTP methods whose capitalization should be normalized
        var methods = [
            'CONNECT',
            'DELETE',
            'GET',
            'HEAD',
            'OPTIONS',
            'PATCH',
            'POST',
            'PUT',
            'TRACE'
        ];
        function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
            if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
                if (input.bodyUsed) {
                    throw new TypeError('Already read');
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options.headers) {
                    this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                    body = input._bodyInit;
                    input.bodyUsed = true;
                }
            } else {
                this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || 'same-origin';
            if (options.headers || !this.headers) {
                this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || 'GET');
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal || function() {
                if ('AbortController' in g) {
                    var ctrl = new AbortController();
                    return ctrl.signal;
                }
            }();
            this.referrer = null;
            if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                throw new TypeError('Body not allowed for GET or HEAD requests');
            }
            this._initBody(body);
            if (this.method === 'GET' || this.method === 'HEAD') {
                if (options.cache === 'no-store' || options.cache === 'no-cache') {
                    // Search for a '_' parameter in the query string
                    var reParamSearch = /([?&])_=[^&]*/;
                    if (reParamSearch.test(this.url)) {
                        // If it already exists then set the value with the current time
                        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
                    } else {
                        // Otherwise add a new '_' parameter to the end with the current time
                        var reQueryString = /\?/;
                        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
                    }
                }
            }
        }
        Request.prototype.clone = function() {
            return new Request(this, {
                body: this._bodyInit
            });
        };
        function decode(body) {
            var form = new FormData();
            body.trim().split('&').forEach(function(bytes) {
                if (bytes) {
                    var split = bytes.split('=');
                    var name = split.shift().replace(/\+/g, ' ');
                    var value = split.join('=').replace(/\+/g, ' ');
                    form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
            });
            return form;
        }
        function parseHeaders(rawHeaders) {
            var headers = new Headers();
            // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
            // https://tools.ietf.org/html/rfc7230#section-3.2
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
            // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
            // https://github.com/github/fetch/issues/748
            // https://github.com/zloirock/core-js/issues/751
            preProcessedHeaders.split('\r').map(function(header) {
                return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header;
            }).forEach(function(line) {
                var parts = line.split(':');
                var key = parts.shift().trim();
                if (key) {
                    var value = parts.join(':').trim();
                    try {
                        headers.append(key, value);
                    } catch (error) {
                        console.warn('Response ' + error.message);
                    }
                }
            });
            return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
            if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            if (!options) {
                options = {};
            }
            this.type = 'default';
            this.status = options.status === undefined ? 200 : options.status;
            if (this.status < 200 || this.status > 599) {
                throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
            }
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
            this.headers = new Headers(options.headers);
            this.url = options.url || '';
            this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
            });
        };
        Response.error = function() {
            var response = new Response(null, {
                status: 200,
                statusText: ''
            });
            response.ok = false;
            response.status = 0;
            response.type = 'error';
            return response;
        };
        var redirectStatuses = [
            301,
            302,
            303,
            307,
            308
        ];
        Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError('Invalid status code');
            }
            return new Response(null, {
                status: status,
                headers: {
                    location: url
                }
            });
        };
        exports1.DOMException = g.DOMException;
        try {
            new exports1.DOMException();
        } catch (err) {
            exports1.DOMException = function(message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
            };
            exports1.DOMException.prototype = Object.create(Error.prototype);
            exports1.DOMException.prototype.constructor = exports1.DOMException;
        }
        function fetch(input, init) {
            return new Promise(function(resolve, reject) {
                var request = new Request(input, init);
                if (request.signal && request.signal.aborted) {
                    return reject(new exports1.DOMException('Aborted', 'AbortError'));
                }
                var xhr = new XMLHttpRequest();
                function abortXhr() {
                    xhr.abort();
                }
                xhr.onload = function() {
                    var options = {
                        statusText: xhr.statusText,
                        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                    };
                    // This check if specifically for when a user fetches a file locally from the file system
                    // Only if the status is out of a normal range
                    if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {
                        options.status = 200;
                    } else {
                        options.status = xhr.status;
                    }
                    options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                    var body = 'response' in xhr ? xhr.response : xhr.responseText;
                    setTimeout(function() {
                        resolve(new Response(body, options));
                    }, 0);
                };
                xhr.onerror = function() {
                    setTimeout(function() {
                        reject(new TypeError('Network request failed'));
                    }, 0);
                };
                xhr.ontimeout = function() {
                    setTimeout(function() {
                        reject(new TypeError('Network request timed out'));
                    }, 0);
                };
                xhr.onabort = function() {
                    setTimeout(function() {
                        reject(new exports1.DOMException('Aborted', 'AbortError'));
                    }, 0);
                };
                function fixUrl(url) {
                    try {
                        return url === '' && g.location.href ? g.location.href : url;
                    } catch (e) {
                        return url;
                    }
                }
                xhr.open(request.method, fixUrl(request.url), true);
                if (request.credentials === 'include') {
                    xhr.withCredentials = true;
                } else if (request.credentials === 'omit') {
                    xhr.withCredentials = false;
                }
                if ('responseType' in xhr) {
                    if (support.blob) {
                        xhr.responseType = 'blob';
                    } else if (support.arrayBuffer) {
                        xhr.responseType = 'arraybuffer';
                    }
                }
                if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
                    var names = [];
                    Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                        names.push(normalizeName(name));
                        xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                    });
                    request.headers.forEach(function(value, name) {
                        if (names.indexOf(name) === -1) {
                            xhr.setRequestHeader(name, value);
                        }
                    });
                } else {
                    request.headers.forEach(function(value, name) {
                        xhr.setRequestHeader(name, value);
                    });
                }
                if (request.signal) {
                    request.signal.addEventListener('abort', abortXhr);
                    xhr.onreadystatechange = function() {
                        // DONE (success or failure)
                        if (xhr.readyState === 4) {
                            request.signal.removeEventListener('abort', abortXhr);
                        }
                    };
                }
                xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
            });
        }
        fetch.polyfill = true;
        if (!g.fetch) {
            g.fetch = fetch;
            g.Headers = Headers;
            g.Request = Request;
            g.Response = Response;
        }
        exports1.Headers = Headers;
        exports1.Request = Request;
        exports1.Response = Response;
        exports1.fetch = fetch;
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
        return exports1;
    }({});
})(__globalThis__);
// This is a ponyfill, so...
__globalThis__.fetch.ponyfill = true;
delete __globalThis__.fetch.polyfill;
// Choose between native implementation (__global__) or custom implementation (__globalThis__)
var ctx = __global__.fetch ? __global__ : __globalThis__;
exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers;
exports.Request = ctx.Request;
exports.Response = ctx.Response;
module.exports = exports;
}}),
"[project]/node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "HttpConnection": ()=>f,
    "default": ()=>f
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/events/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$browser$2d$ponyfill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-http-connection/node_modules/cross-fetch/dist/browser-ponyfill.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/safe-json/dist/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js [app-client] (ecmascript)");
;
;
;
;
var P = Object.defineProperty, w = Object.defineProperties, E = Object.getOwnPropertyDescriptors, c = Object.getOwnPropertySymbols, L = Object.prototype.hasOwnProperty, O = Object.prototype.propertyIsEnumerable, l = (r, t, e)=>t in r ? P(r, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: e
    }) : r[t] = e, p = (r, t)=>{
    for(var e in t || (t = {}))L.call(t, e) && l(r, e, t[e]);
    if (c) for (var e of c(t))O.call(t, e) && l(r, e, t[e]);
    return r;
}, v = (r, t)=>w(r, E(t));
const j = {
    Accept: "application/json",
    "Content-Type": "application/json"
}, T = "POST", d = {
    headers: j,
    method: T
}, g = 10;
class f {
    get connected() {
        return this.isAvailable;
    }
    get connecting() {
        return this.registering;
    }
    on(t, e) {
        this.events.on(t, e);
    }
    once(t, e) {
        this.events.once(t, e);
    }
    off(t, e) {
        this.events.off(t, e);
    }
    removeListener(t, e) {
        this.events.removeListener(t, e);
    }
    async open() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.url;
        await this.register(t);
    }
    async close() {
        if (!this.isAvailable) throw new Error("Connection already closed");
        this.onClose();
    }
    async send(t) {
        this.isAvailable || await this.register();
        try {
            const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeJsonStringify"])(t), s = await (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$browser$2d$ponyfill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.url, v(p({}, d), {
                body: e
            }))).json();
            this.onPayload({
                data: s
            });
        } catch (e) {
            this.onError(t.id, e);
        }
    }
    async register() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.url;
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHttpUrl"])(t)) throw new Error("Provided URL is not compatible with HTTP connection: ".concat(t));
        if (this.registering) {
            const e = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= e || this.events.listenerCount("open") >= e) && this.events.setMaxListeners(e + 1), new Promise((s, i)=>{
                this.events.once("register_error", (n)=>{
                    this.resetMaxListeners(), i(n);
                }), this.events.once("open", ()=>{
                    if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
                    s();
                });
            });
        }
        this.url = t, this.registering = !0;
        try {
            if (!this.disableProviderPing) {
                const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeJsonStringify"])({
                    id: 1,
                    jsonrpc: "2.0",
                    method: "test",
                    params: []
                });
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$node_modules$2f$cross$2d$fetch$2f$dist$2f$browser$2d$ponyfill$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(t, v(p({}, d), {
                    body: e
                }));
            }
            this.onOpen();
        } catch (e) {
            const s = this.parseError(e);
            throw this.events.emit("register_error", s), this.onClose(), s;
        }
    }
    onOpen() {
        this.isAvailable = !0, this.registering = !1, this.events.emit("open");
    }
    onClose() {
        this.isAvailable = !1, this.registering = !1, this.events.emit("close");
    }
    onPayload(t) {
        if (typeof t.data > "u") return;
        const e = typeof t.data == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$safe$2d$json$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeJsonParse"])(t.data) : t.data;
        this.events.emit("payload", e);
    }
    onError(t, e) {
        const s = this.parseError(e), i = s.message || s.toString(), n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatJsonRpcError"])(t, i);
        this.events.emit("payload", n);
    }
    parseError(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.url;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseConnectionError"])(t, e, "HTTP");
    }
    resetMaxListeners() {
        this.events.getMaxListeners() > g && this.events.setMaxListeners(g);
    }
    constructor(t, e = !1){
        if (this.url = t, this.disableProviderPing = e, this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventEmitter"], this.isAvailable = !1, this.registering = !1, !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$url$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isHttpUrl"])(t)) throw new Error("Provided URL is not compatible with HTTP connection: ".concat(t));
        this.url = t, this.disableProviderPing = e;
    }
}
;
 //# sourceMappingURL=index.es.js.map
}),
"[project]/node_modules/thirdweb/node_modules/@walletconnect/universal-provider/dist/index.es.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "UniversalProvider": ()=>Bs,
    "default": ()=>J
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$sign$2d$client$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/sign-client/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@walletconnect/utils/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$logger$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/logger/dist/index.es.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pino$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pino$3e$__ = __turbopack_context__.i("[project]/node_modules/pino/browser.js [app-client] (ecmascript) <export default as pino>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$logger$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/logger/dist/index.es.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/events/events.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const pe = "error", We = "wss://relay.walletconnect.org", Ke = "wc", Ve = "universal_provider", x = "".concat(Ke, "@2:").concat(Ve, ":"), de = "https://rpc.walletconnect.org/v1/", ue = "generic", Ye = "".concat(de, "bundler"), $ = "call_status", Xe = 86400, m = {
    DEFAULT_CHAIN_CHANGED: "default_chain_changed"
};
function K(s) {
    return s == null || typeof s != "object" && typeof s != "function";
}
function le(s) {
    return Object.getOwnPropertySymbols(s).filter((e)=>Object.prototype.propertyIsEnumerable.call(s, e));
}
function fe(s) {
    return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s);
}
const Qe = "[object RegExp]", me = "[object String]", ve = "[object Number]", ge = "[object Boolean]", Pe = "[object Arguments]", Ze = "[object Symbol]", Te = "[object Date]", et = "[object Map]", tt = "[object Set]", st = "[object Array]", it = "[object ArrayBuffer]", rt = "[object Object]", nt = "[object DataView]", at = "[object Uint8Array]", ct = "[object Uint8ClampedArray]", ot = "[object Uint16Array]", ht = "[object Uint32Array]", pt = "[object Int8Array]", dt = "[object Int16Array]", ut = "[object Int32Array]", lt = "[object Float32Array]", ft = "[object Float64Array]";
function V(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function mt(s, e) {
    return O(s, void 0, s, new Map, e);
}
function O(s, e, t) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new Map, n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
    const a = n === null || n === void 0 ? void 0 : n(s, e, t, i);
    if (a != null) return a;
    if (K(s)) return s;
    if (i.has(s)) return i.get(s);
    if (Array.isArray(s)) {
        const r = new Array(s.length);
        i.set(s, r);
        for(let c = 0; c < s.length; c++)r[c] = O(s[c], c, t, i, n);
        return Object.hasOwn(s, "index") && (r.index = s.index), Object.hasOwn(s, "input") && (r.input = s.input), r;
    }
    if (s instanceof Date) return new Date(s.getTime());
    if (s instanceof RegExp) {
        const r = new RegExp(s.source, s.flags);
        return r.lastIndex = s.lastIndex, r;
    }
    if (s instanceof Map) {
        const r = new Map;
        i.set(s, r);
        for (const [c, o] of s)r.set(c, O(o, c, t, i, n));
        return r;
    }
    if (s instanceof Set) {
        const r = new Set;
        i.set(s, r);
        for (const c of s)r.add(O(c, void 0, t, i, n));
        return r;
    }
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] < "u" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(s)) return s.subarray();
    if (V(s)) {
        const r = new (Object.getPrototypeOf(s)).constructor(s.length);
        i.set(s, r);
        for(let c = 0; c < s.length; c++)r[c] = O(s[c], c, t, i, n);
        return r;
    }
    if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
    if (s instanceof DataView) {
        const r = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
        return i.set(s, r), y(r, s, t, i, n), r;
    }
    if (typeof File < "u" && s instanceof File) {
        const r = new File([
            s
        ], s.name, {
            type: s.type
        });
        return i.set(s, r), y(r, s, t, i, n), r;
    }
    if (s instanceof Blob) {
        const r = new Blob([
            s
        ], {
            type: s.type
        });
        return i.set(s, r), y(r, s, t, i, n), r;
    }
    if (s instanceof Error) {
        const r = new s.constructor;
        return i.set(s, r), r.message = s.message, r.name = s.name, r.stack = s.stack, r.cause = s.cause, y(r, s, t, i, n), r;
    }
    if (typeof s == "object" && vt(s)) {
        const r = Object.create(Object.getPrototypeOf(s));
        return i.set(s, r), y(r, s, t, i, n), r;
    }
    return s;
}
function y(s, e) {
    let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : s, i = arguments.length > 3 ? arguments[3] : void 0, n = arguments.length > 4 ? arguments[4] : void 0;
    const a = [
        ...Object.keys(e),
        ...le(e)
    ];
    for(let r = 0; r < a.length; r++){
        const c = a[r], o = Object.getOwnPropertyDescriptor(s, c);
        (o == null || o.writable) && (s[c] = O(e[c], c, t, i, n));
    }
}
function vt(s) {
    switch(fe(s)){
        case Pe:
        case st:
        case it:
        case nt:
        case ge:
        case Te:
        case lt:
        case ft:
        case pt:
        case dt:
        case ut:
        case et:
        case ve:
        case rt:
        case Qe:
        case tt:
        case me:
        case Ze:
        case at:
        case ct:
        case ot:
        case ht:
            return !0;
        default:
            return !1;
    }
}
function gt(s, e) {
    return mt(s, (t, i, n, a)=>{
        const r = e === null || e === void 0 ? void 0 : e(t, i, n, a);
        if (r != null) return r;
        if (typeof s == "object") switch(Object.prototype.toString.call(s)){
            case ve:
            case me:
            case ge:
                {
                    const c = new s.constructor(s === null || s === void 0 ? void 0 : s.valueOf());
                    return y(c, s), c;
                }
            case Pe:
                {
                    const c = {};
                    return y(c, s), c.length = s.length, c[Symbol.iterator] = s[Symbol.iterator], c;
                }
            default:
                return;
        }
    });
}
function we(s) {
    return gt(s);
}
function ye(s) {
    return s !== null && typeof s == "object" && fe(s) === "[object Arguments]";
}
function be(s) {
    return typeof s == "object" && s !== null;
}
function Pt() {}
function wt(s) {
    return V(s);
}
function yt(s) {
    if (typeof s != "object" || s == null) return !1;
    if (Object.getPrototypeOf(s) === null) return !0;
    if (Object.prototype.toString.call(s) !== "[object Object]") {
        var _Object_getOwnPropertyDescriptor;
        const t = s[Symbol.toStringTag];
        return t == null || !((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)) === null || _Object_getOwnPropertyDescriptor === void 0 ? void 0 : _Object_getOwnPropertyDescriptor.writable) ? !1 : s.toString() === "[object ".concat(t, "]");
    }
    let e = s;
    for(; Object.getPrototypeOf(e) !== null;)e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(s) === e;
}
function bt(s) {
    if (K(s)) return s;
    if (Array.isArray(s) || V(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
    const e = Object.getPrototypeOf(s), t = e.constructor;
    if (s instanceof Date || s instanceof Map || s instanceof Set) return new t(s);
    if (s instanceof RegExp) {
        const i = new t(s);
        return i.lastIndex = s.lastIndex, i;
    }
    if (s instanceof DataView) return new t(s.buffer.slice(0));
    if (s instanceof Error) {
        const i = new t(s.message);
        return i.stack = s.stack, i.name = s.name, i.cause = s.cause, i;
    }
    if (typeof File < "u" && s instanceof File) return new t([
        s
    ], s.name, {
        type: s.type,
        lastModified: s.lastModified
    });
    if (typeof s == "object") {
        const i = Object.create(e);
        return Object.assign(i, s);
    }
    return s;
}
function It(s) {
    for(var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        e[_key - 1] = arguments[_key];
    }
    const t = e.slice(0, -1), i = e[e.length - 1];
    let n = s;
    for(let a = 0; a < t.length; a++){
        const r = t[a];
        n = L(n, r, i, new Map);
    }
    return n;
}
function L(s, e, t, i) {
    if (K(s) && (s = Object(s)), e == null || typeof e != "object") return s;
    if (i.has(e)) return bt(i.get(e));
    if (i.set(e, s), Array.isArray(e)) {
        e = e.slice();
        var _e_a;
        for(let a = 0; a < e.length; a++)e[a] = (_e_a = e[a]) !== null && _e_a !== void 0 ? _e_a : void 0;
    }
    const n = [
        ...Object.keys(e),
        ...le(e)
    ];
    for(let a = 0; a < n.length; a++){
        const r = n[a];
        let c = e[r], o = s[r];
        if (ye(c) && (c = {
            ...c
        }), ye(o) && (o = {
            ...o
        }), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] < "u" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(c) && (c = we(c)), Array.isArray(c)) if (typeof o == "object" && o != null) {
            const u = [], p = Reflect.ownKeys(o);
            for(let w = 0; w < p.length; w++){
                const l = p[w];
                u[l] = o[l];
            }
            o = u;
        } else o = [];
        const d = t(o, c, r, s, e, i);
        d != null ? s[r] = d : Array.isArray(c) || be(o) && be(c) ? s[r] = L(o, c, t, i) : o == null && yt(c) ? s[r] = L({}, c, t, i) : o == null && wt(c) ? s[r] = we(c) : (o === void 0 || c !== void 0) && (s[r] = c);
    }
    return s;
}
function $t(s) {
    for(var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        e[_key - 1] = arguments[_key];
    }
    return It(s, ...e, Pt);
}
var Ot = Object.defineProperty, Ct = Object.defineProperties, At = Object.getOwnPropertyDescriptors, Ie = Object.getOwnPropertySymbols, Et = Object.prototype.hasOwnProperty, Ht = Object.prototype.propertyIsEnumerable, $e = (s, e, t)=>e in s ? Ot(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, M = (s, e)=>{
    for(var t in e || (e = {}))Et.call(e, t) && $e(s, t, e[t]);
    if (Ie) for (var t of Ie(e))Ht.call(e, t) && $e(s, t, e[t]);
    return s;
}, St = (s, e)=>Ct(s, At(e));
function f(s, e, t) {
    var i;
    const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseChainId"])(s);
    return ((i = e.rpcMap) == null ? void 0 : i[n.reference]) || "".concat(de, "?chainId=").concat(n.namespace, ":").concat(n.reference, "&projectId=").concat(t);
}
function b(s) {
    return s.includes(":") ? s.split(":")[1] : s;
}
function Oe(s) {
    return s.map((e)=>"".concat(e.split(":")[0], ":").concat(e.split(":")[1]));
}
function Nt(s, e) {
    const t = Object.keys(e.namespaces).filter((n)=>n.includes(s));
    if (!t.length) return [];
    const i = [];
    return t.forEach((n)=>{
        const a = e.namespaces[n].accounts;
        i.push(...a);
    }), i;
}
function Ce(s) {
    return Object.fromEntries(Object.entries(s).filter((param)=>{
        let [e, t] = param;
        var i, n;
        return ((i = t === null || t === void 0 ? void 0 : t.chains) == null ? void 0 : i.length) && ((n = t === null || t === void 0 ? void 0 : t.chains) == null ? void 0 : n.length) > 0;
    }));
}
function B() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const t = Ce(Ae(s)), i = Ce(Ae(e));
    return $t(t, i);
}
function Ae(s) {
    var e, t, i, n, a;
    const r = {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidObject"])(s)) return r;
    for (const [c, o] of Object.entries(s)){
        const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCaipNamespace"])(c) ? [
            c
        ] : o.chains, u = o.methods || [], p = o.events || [], w = o.rpcMap || {}, l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(c);
        r[l] = St(M(M({}, r[l]), o), {
            chains: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeArrays"])(d, (e = r[l]) == null ? void 0 : e.chains),
            methods: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeArrays"])(u, (t = r[l]) == null ? void 0 : t.methods),
            events: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mergeArrays"])(p, (i = r[l]) == null ? void 0 : i.events)
        }), ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidObject"])(w) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidObject"])(((n = r[l]) == null ? void 0 : n.rpcMap) || {})) && (r[l].rpcMap = M(M({}, w), (a = r[l]) == null ? void 0 : a.rpcMap));
    }
    return r;
}
function Ee(s) {
    return s.includes(":") ? s.split(":")[2] : s;
}
function He(s) {
    const e = {};
    for (const [t, i] of Object.entries(s)){
        const n = i.methods || [], a = i.events || [], r = i.accounts || [], c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCaipNamespace"])(t) ? [
            t
        ] : i.chains ? i.chains : Oe(i.accounts);
        e[t] = {
            chains: c,
            methods: n,
            events: a,
            accounts: r
        };
    }
    return e;
}
function Y(s) {
    return typeof s == "number" ? s : s.includes("0x") ? parseInt(s, 16) : (s = s.includes(":") ? s.split(":")[1] : s, isNaN(Number(s)) ? s : Number(s));
}
function qt(s) {
    try {
        const e = JSON.parse(s);
        return typeof e == "object" && e !== null && !Array.isArray(e);
    } catch (e) {
        return !1;
    }
}
const Se = {}, h = (s)=>Se[s], X = (s, e)=>{
    Se[s] = e;
};
var Dt = Object.defineProperty, Ne = Object.getOwnPropertySymbols, jt = Object.prototype.hasOwnProperty, Rt = Object.prototype.propertyIsEnumerable, qe = (s, e, t)=>e in s ? Dt(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, De = (s, e)=>{
    for(var t in e || (e = {}))jt.call(e, t) && qe(s, t, e[t]);
    if (Ne) for (var t of Ne(e))Rt.call(e, t) && qe(s, t, e[t]);
    return s;
};
const je = "eip155", _t = [
    "atomic",
    "flow-control",
    "paymasterService",
    "sessionKeys",
    "auxiliaryFunds"
], Ft = (s)=>s && s.startsWith("0x") ? BigInt(s).toString(10) : s, Q = (s)=>s && s.startsWith("0x") ? s : "0x".concat(BigInt(s).toString(16)), Re = (s)=>Object.keys(s).filter((e)=>_t.includes(e)).reduce((e, t)=>(e[t] = Ut(s[t]), e), {}), Ut = (s)=>typeof s == "string" && qt(s) ? JSON.parse(s) : s, xt = (s, e, t)=>{
    const { sessionProperties: i = {}, scopedProperties: n = {} } = s, a = {};
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidObject"])(n) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidObject"])(i)) return;
    const r = Re(i);
    for (const c of t){
        const o = Ft(c);
        if (!o) continue;
        a[Q(o)] = r;
        const d = n === null || n === void 0 ? void 0 : n["".concat(je, ":").concat(o)];
        if (d) {
            const u = d === null || d === void 0 ? void 0 : d["".concat(je, ":").concat(o, ":").concat(e)];
            a[Q(o)] = De(De({}, a[Q(o)]), Re(u || d));
        }
    }
    for (const [c, o] of Object.entries(a))Object.keys(o).length === 0 && delete a[c];
    return Object.keys(a).length > 0 ? a : void 0;
};
var Lt = Object.defineProperty, Mt = (s, e, t)=>e in s ? Lt(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, Bt = (s, e, t)=>Mt(s, typeof e != "symbol" ? e + "" : e, t);
let Z;
class re {
    async getItem(e) {
        return await this.storage.getItem(e);
    }
    async setItem(e, t) {
        return await this.storage.setItem(e, t);
    }
    async removeItem(e) {
        return await this.storage.removeItem(e);
    }
    static getStorage(e) {
        return Z || (Z = new re(e)), Z;
    }
    constructor(e){
        Bt(this, "storage"), this.storage = e;
    }
}
var Gt = Object.defineProperty, Jt = Object.defineProperties, zt = Object.getOwnPropertyDescriptors, _e = Object.getOwnPropertySymbols, kt = Object.prototype.hasOwnProperty, Wt = Object.prototype.propertyIsEnumerable, Fe = (s, e, t)=>e in s ? Gt(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, Kt = (s, e)=>{
    for(var t in e || (e = {}))kt.call(e, t) && Fe(s, t, e[t]);
    if (_e) for (var t of _e(e))Wt.call(e, t) && Fe(s, t, e[t]);
    return s;
}, Vt = (s, e)=>Jt(s, zt(e));
async function Yt(s, e) {
    const t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseChainId"])(s.result.capabilities.caip345.caip2), i = s.result.capabilities.caip345.transactionHashes, n = await Promise.allSettled(i.map((p)=>Xt(t.reference, p, e))), a = n.filter((p)=>p.status === "fulfilled").map((p)=>p.value).filter((p)=>p);
    n.filter((p)=>p.status === "rejected").forEach((p)=>console.warn("Failed to fetch transaction receipt:", p.reason));
    const r = !a.length || a.some((p)=>!p), c = a.every((p)=>(p === null || p === void 0 ? void 0 : p.status) === "0x1"), o = a.every((p)=>(p === null || p === void 0 ? void 0 : p.status) === "0x0"), d = a.some((p)=>(p === null || p === void 0 ? void 0 : p.status) === "0x0");
    let u;
    return r ? u = 100 : c ? u = 200 : o ? u = 500 : d && (u = 600), {
        id: s.result.id,
        version: s.request.version,
        atomic: s.request.atomicRequired,
        chainId: s.request.chainId,
        capabilities: s.result.capabilities,
        receipts: a,
        status: u
    };
}
async function Xt(s, e, t) {
    return await t(parseInt(s)).request((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatJsonRpcRequest"])("eth_getTransactionReceipt", [
        e
    ]));
}
async function Qt(param) {
    let { sendCalls: s, storage: e } = param;
    const t = await e.getItem($);
    await e.setItem($, Vt(Kt({}, t), {
        [s.result.id]: {
            request: s.request,
            result: s.result,
            expiry: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["calcExpiry"])(Xe)
        }
    }));
}
async function Zt(param) {
    let { resultId: s, storage: e } = param;
    const t = await e.getItem($);
    if (t) {
        delete t[s], await e.setItem($, t);
        for(const i in t)(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isExpired"])(t[i].expiry) && delete t[i];
        await e.setItem($, t);
    }
}
async function Tt(param) {
    let { resultId: s, storage: e } = param;
    const t = await e.getItem($), i = t === null || t === void 0 ? void 0 : t[s];
    if (i && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isExpired"])(i.expiry)) return i;
    await Zt({
        resultId: s,
        storage: e
    });
}
var es = Object.defineProperty, ts = (s, e, t)=>e in s ? es(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, C = (s, e, t)=>ts(s, typeof e != "symbol" ? e + "" : e, t);
class ss {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(e));
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]) || [] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            const n = b(t);
            e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        C(this, "name", "polkadot"), C(this, "client"), C(this, "httpProviders"), C(this, "events"), C(this, "namespace"), C(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var is = Object.defineProperty, rs = Object.defineProperties, ns = Object.getOwnPropertyDescriptors, Ue = Object.getOwnPropertySymbols, as = Object.prototype.hasOwnProperty, cs = Object.prototype.propertyIsEnumerable, T = (s, e, t)=>e in s ? is(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, ee = (s, e)=>{
    for(var t in e || (e = {}))as.call(e, t) && T(s, t, e[t]);
    if (Ue) for (var t of Ue(e))cs.call(e, t) && T(s, t, e[t]);
    return s;
}, te = (s, e)=>rs(s, ns(e)), I = (s, e, t)=>T(s, typeof e != "symbol" ? e + "" : e, t);
class os {
    async request(e) {
        switch(e.request.method){
            case "eth_requestAccounts":
                return this.getAccounts();
            case "eth_accounts":
                return this.getAccounts();
            case "wallet_switchEthereumChain":
                return await this.handleSwitchChain(e);
            case "eth_chainId":
                return parseInt(this.getDefaultChain());
            case "wallet_getCapabilities":
                return await this.getCapabilities(e);
            case "wallet_getCallsStatus":
                return await this.getCallStatus(e);
            case "wallet_sendCalls":
                return await this.sendCalls(e);
        }
        return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(parseInt(e), t), this.chainId = parseInt(e), this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(e));
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId.toString();
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    createHttpProvider(e, t) {
        const i = t || f("".concat(this.name, ":").concat(e), this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpConnection"](i, h("disableProviderPing")));
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            const n = parseInt(b(t));
            e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    getHttpProvider(e) {
        const t = e || this.chainId;
        return this.httpProviders[t] || (this.httpProviders = te(ee({}, this.httpProviders), {
            [t]: this.createHttpProvider(t)
        }), this.httpProviders[t]);
    }
    async handleSwitchChain(e) {
        var t, i;
        let n = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : "0x0";
        n = n.startsWith("0x") ? n : "0x".concat(n);
        const a = parseInt(n, 16);
        if (this.isChainApproved(a)) this.setDefaultChain("".concat(a));
        else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({
            topic: e.topic,
            request: {
                method: e.request.method,
                params: [
                    {
                        chainId: n
                    }
                ]
            },
            chainId: (i = this.namespace.chains) == null ? void 0 : i[0]
        }), this.setDefaultChain("".concat(a));
        else throw new Error("Failed to switch to chain 'eip155:".concat(a, "'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method."));
        return null;
    }
    isChainApproved(e) {
        return this.namespace.chains.includes("".concat(this.name, ":").concat(e));
    }
    async getCapabilities(e) {
        var t, i, n, a, r;
        const c = (i = (t = e.request) == null ? void 0 : t.params) == null ? void 0 : i[0], o = ((a = (n = e.request) == null ? void 0 : n.params) == null ? void 0 : a[1]) || [];
        if (!c) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
        const d = this.client.session.get(e.topic), u = ((r = d === null || d === void 0 ? void 0 : d.sessionProperties) == null ? void 0 : r.capabilities) || {}, p = "".concat(c).concat(o.join(",")), w = u === null || u === void 0 ? void 0 : u[p];
        if (w) return w;
        let l;
        try {
            l = xt(d, c, o);
        } catch (z) {
            console.warn("Failed to extract capabilities from session", z);
        }
        if (l) return l;
        const ne = await this.client.request(e);
        try {
            await this.client.session.update(e.topic, {
                sessionProperties: te(ee({}, d.sessionProperties || {}), {
                    capabilities: te(ee({}, u || {}), {
                        [p]: ne
                    })
                })
            });
        } catch (z) {
            console.warn("Failed to update session with capabilities", z);
        }
        return ne;
    }
    async getCallStatus(e) {
        var t, i, n;
        const a = this.client.session.get(e.topic), r = (t = a.sessionProperties) == null ? void 0 : t.bundler_name;
        if (r) {
            const d = this.getBundlerUrl(e.chainId, r);
            try {
                return await this.getUserOperationReceipt(d, e);
            } catch (u) {
                console.warn("Failed to fetch call status from bundler", u, d);
            }
        }
        const c = (i = a.sessionProperties) == null ? void 0 : i.bundler_url;
        if (c) try {
            return await this.getUserOperationReceipt(c, e);
        } catch (d) {
            console.warn("Failed to fetch call status from custom bundler", d, c);
        }
        const o = await Tt({
            resultId: (n = e.request.params) == null ? void 0 : n[0],
            storage: this.storage
        });
        if (o) try {
            return await Yt(o, this.getHttpProvider.bind(this));
        } catch (d) {
            console.warn("Failed to fetch call status from stored send calls", d, o);
        }
        if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
        throw new Error("Fetching call status not approved by the wallet.");
    }
    async getUserOperationReceipt(e, t) {
        var i;
        const n = new URL(e), a = await fetch(n, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatJsonRpcRequest"])("eth_getUserOperationReceipt", [
                (i = t.request.params) == null ? void 0 : i[0]
            ]))
        });
        if (!a.ok) throw new Error("Failed to fetch user operation receipt - ".concat(a.status));
        return await a.json();
    }
    getBundlerUrl(e, t) {
        return "".concat(Ye, "?projectId=").concat(this.client.core.projectId, "&chainId=").concat(e, "&bundler=").concat(t);
    }
    async sendCalls(e) {
        var t, i, n;
        const a = await this.client.request(e), r = (t = e.request.params) == null ? void 0 : t[0], c = a === null || a === void 0 ? void 0 : a.id, o = (a === null || a === void 0 ? void 0 : a.capabilities) || {}, d = (i = o === null || o === void 0 ? void 0 : o.caip345) == null ? void 0 : i.caip2, u = (n = o === null || o === void 0 ? void 0 : o.caip345) == null ? void 0 : n.transactionHashes;
        return !c || !d || !(u != null && u.length) || await Qt({
            sendCalls: {
                request: r,
                result: a
            },
            storage: this.storage
        }), a;
    }
    constructor(e){
        I(this, "name", "eip155"), I(this, "client"), I(this, "chainId"), I(this, "namespace"), I(this, "httpProviders"), I(this, "events"), I(this, "storage"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain()), this.storage = re.getStorage(this.client.core.storage);
    }
}
var hs = Object.defineProperty, ps = (s, e, t)=>e in s ? hs(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, A = (s, e, t)=>ps(s, typeof e != "symbol" ? e + "" : e, t);
class ds {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(e));
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            const n = b(t);
            e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        A(this, "name", "solana"), A(this, "client"), A(this, "httpProviders"), A(this, "events"), A(this, "namespace"), A(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var us = Object.defineProperty, ls = (s, e, t)=>e in s ? us(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, E = (s, e, t)=>ls(s, typeof e != "symbol" ? e + "" : e, t);
class fs {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(this.chainId));
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            const n = b(t);
            e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        E(this, "name", "cosmos"), E(this, "client"), E(this, "httpProviders"), E(this, "events"), E(this, "namespace"), E(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var ms = Object.defineProperty, vs = (s, e, t)=>e in s ? ms(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, H = (s, e, t)=>vs(s, typeof e != "symbol" ? e + "" : e, t);
class gs {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        if (!this.httpProviders[e]) {
            const i = t || f("".concat(this.name, ":").concat(e), this.namespace, this.client.core.projectId);
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            this.setHttpProvider(e, i);
        }
        this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(this.chainId));
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace, this.client.core.projectId);
        return typeof i > "u" ? void 0 : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        H(this, "name", "algorand"), H(this, "client"), H(this, "httpProviders"), H(this, "events"), H(this, "namespace"), H(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var Ps = Object.defineProperty, ws = (s, e, t)=>e in s ? Ps(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, S = (s, e, t)=>ws(s, typeof e != "symbol" ? e + "" : e, t);
class ys {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(this.chainId));
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            const i = this.getCardanoRPCUrl(t), n = b(t);
            e[n] = this.createHttpProvider(n, i);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    getCardanoRPCUrl(e) {
        const t = this.namespace.rpcMap;
        if (t) return t[e];
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || this.getCardanoRPCUrl(e);
        if (!i) throw new Error("No RPC url provided for chainId: ".concat(e));
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        S(this, "name", "cip34"), S(this, "client"), S(this, "httpProviders"), S(this, "events"), S(this, "namespace"), S(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var bs = Object.defineProperty, Is = (s, e, t)=>e in s ? bs(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, N = (s, e, t)=>Is(s, typeof e != "symbol" ? e + "" : e, t);
class $s {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(e));
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            const n = b(t);
            e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        N(this, "name", "elrond"), N(this, "client"), N(this, "httpProviders"), N(this, "events"), N(this, "namespace"), N(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var Os = Object.defineProperty, Cs = (s, e, t)=>e in s ? Os(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, q = (s, e, t)=>Cs(s, typeof e != "symbol" ? e + "" : e, t);
class As {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(e));
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            const n = b(t);
            e[n] = this.createHttpProvider(n, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        q(this, "name", "multiversx"), q(this, "client"), q(this, "httpProviders"), q(this, "events"), q(this, "namespace"), q(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var Es = Object.defineProperty, Hs = (s, e, t)=>e in s ? Es(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, D = (s, e, t)=>Hs(s, typeof e != "symbol" ? e + "" : e, t);
class Ss {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        if (this.chainId = e, !this.httpProviders[e]) {
            const i = t || f("".concat(this.name, ":").concat(e), this.namespace);
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            this.setHttpProvider(e, i);
        }
        this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(this.chainId));
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]) || [] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            var i;
            e[t] = this.createHttpProvider(t, (i = this.namespace.rpcMap) == null ? void 0 : i[t]);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace);
        return typeof i > "u" ? void 0 : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        D(this, "name", "near"), D(this, "client"), D(this, "httpProviders"), D(this, "events"), D(this, "namespace"), D(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var Ns = Object.defineProperty, qs = (s, e, t)=>e in s ? Ns(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, j = (s, e, t)=>qs(s, typeof e != "symbol" ? e + "" : e, t);
class Ds {
    updateNamespace(e) {
        this.namespace = Object.assign(this.namespace, e);
    }
    requestAccounts() {
        return this.getAccounts();
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
    }
    setDefaultChain(e, t) {
        if (this.chainId = e, !this.httpProviders[e]) {
            const i = t || f("".concat(this.name, ":").concat(e), this.namespace);
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            this.setHttpProvider(e, i);
        }
        this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(this.chainId));
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]) || [] : [];
    }
    createHttpProviders() {
        const e = {};
        return this.namespace.chains.forEach((t)=>{
            e[t] = this.createHttpProvider(t);
        }), e;
    }
    getHttpProvider() {
        const e = "".concat(this.name, ":").concat(this.chainId), t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace);
        return typeof i > "u" ? void 0 : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i));
    }
    constructor(e){
        j(this, "name", "tezos"), j(this, "client"), j(this, "httpProviders"), j(this, "events"), j(this, "namespace"), j(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
    }
}
var js = Object.defineProperty, Rs = (s, e, t)=>e in s ? js(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, R = (s, e, t)=>Rs(s, typeof e != "symbol" ? e + "" : e, t);
class _s {
    updateNamespace(e) {
        this.namespace.chains = [
            ...new Set((this.namespace.chains || []).concat(e.chains || []))
        ], this.namespace.accounts = [
            ...new Set((this.namespace.accounts || []).concat(e.accounts || []))
        ], this.namespace.methods = [
            ...new Set((this.namespace.methods || []).concat(e.methods || []))
        ], this.namespace.events = [
            ...new Set((this.namespace.events || []).concat(e.events || []))
        ], this.httpProviders = this.createHttpProviders();
    }
    requestAccounts() {
        return this.getAccounts();
    }
    request(e) {
        return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
    }
    setDefaultChain(e, t) {
        this.httpProviders[e] || this.setHttpProvider(e, t), this.chainId = e, this.events.emit(m.DEFAULT_CHAIN_CHANGED, "".concat(this.name, ":").concat(e));
    }
    getDefaultChain() {
        if (this.chainId) return this.chainId;
        if (this.namespace.defaultChain) return this.namespace.defaultChain;
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return e.split(":")[1];
    }
    getNamespaceName() {
        const e = this.namespace.chains[0];
        if (!e) throw new Error("ChainId not found");
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseChainId"])(e).namespace;
    }
    getAccounts() {
        const e = this.namespace.accounts;
        return e ? [
            ...new Set(e.filter((t)=>t.split(":")[1] === this.chainId.toString()).map((t)=>t.split(":")[2]))
        ] : [];
    }
    createHttpProviders() {
        var e, t;
        const i = {};
        return (t = (e = this.namespace) == null ? void 0 : e.accounts) == null || t.forEach((n)=>{
            const a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseChainId"])(n);
            i[a.reference] = this.createHttpProvider(n);
        }), i;
    }
    getHttpProvider(e) {
        const t = this.httpProviders[e];
        if (typeof t > "u") throw new Error("JSON-RPC provider for ".concat(e, " not found"));
        return t;
    }
    setHttpProvider(e, t) {
        const i = this.createHttpProvider(e, t);
        i && (this.httpProviders[e] = i);
    }
    createHttpProvider(e, t) {
        const i = t || f(e, this.namespace, this.client.core.projectId);
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$provider$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["JsonRpcProvider"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$http$2d$connection$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](i, h("disableProviderPing")));
    }
    constructor(e){
        R(this, "name", ue), R(this, "client"), R(this, "httpProviders"), R(this, "events"), R(this, "namespace"), R(this, "chainId"), this.namespace = e.namespace, this.events = h("events"), this.client = h("client"), this.chainId = this.getDefaultChain(), this.name = this.getNamespaceName(), this.httpProviders = this.createHttpProviders();
    }
}
var Fs = Object.defineProperty, Us = Object.defineProperties, xs = Object.getOwnPropertyDescriptors, xe = Object.getOwnPropertySymbols, Ls = Object.prototype.hasOwnProperty, Ms = Object.prototype.propertyIsEnumerable, se = (s, e, t)=>e in s ? Fs(s, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : s[e] = t, G = (s, e)=>{
    for(var t in e || (e = {}))Ls.call(e, t) && se(s, t, e[t]);
    if (xe) for (var t of xe(e))Ms.call(e, t) && se(s, t, e[t]);
    return s;
}, ie = (s, e)=>Us(s, xs(e)), v = (s, e, t)=>se(s, typeof e != "symbol" ? e + "" : e, t);
class J {
    static async init(e) {
        const t = new J(e);
        return await t.initialize(), t;
    }
    async request(e, t, i) {
        const [n, a] = this.validateChain(t);
        if (!this.session) throw new Error("Please call connect() before request()");
        return await this.getProvider(n).request({
            request: G({}, e),
            chainId: "".concat(n, ":").concat(a),
            topic: this.session.topic,
            expiry: i
        });
    }
    sendAsync(e, t, i, n) {
        const a = new Date().getTime();
        this.request(e, i, n).then((r)=>t(null, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$jsonrpc$2d$utils$2f$dist$2f$esm$2f$format$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatJsonRpcResult"])(a, r))).catch((r)=>t(r, void 0));
    }
    async enable() {
        if (!this.client) throw new Error("Sign Client not initialized");
        return this.session || await this.connect({
            namespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties
        }), await this.requestAccounts();
    }
    async disconnect() {
        var e;
        if (!this.session) throw new Error("Please call connect() before enable()");
        await this.client.disconnect({
            topic: (e = this.session) == null ? void 0 : e.topic,
            reason: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSdkError"])("USER_DISCONNECTED")
        }), await this.cleanup();
    }
    async connect(e) {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (this.setNamespaces(e), this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
    }
    async authenticate(e, t) {
        if (!this.client) throw new Error("Sign Client not initialized");
        this.setNamespaces(e), await this.cleanupPendingPairings();
        const { uri: i, response: n } = await this.client.authenticate(e, t);
        i && (this.uri = i, this.events.emit("display_uri", i));
        const a = await n();
        if (this.session = a.session, this.session) {
            const r = He(this.session.namespaces);
            this.namespaces = B(this.namespaces, r), await this.persist("namespaces", this.namespaces), this.onConnect();
        }
        return a;
    }
    on(e, t) {
        this.events.on(e, t);
    }
    once(e, t) {
        this.events.once(e, t);
    }
    removeListener(e, t) {
        this.events.removeListener(e, t);
    }
    off(e, t) {
        this.events.off(e, t);
    }
    get isWalletConnect() {
        return !0;
    }
    async pair(e) {
        const { uri: t, approval: i } = await this.client.connect({
            pairingTopic: e,
            requiredNamespaces: this.namespaces,
            optionalNamespaces: this.optionalNamespaces,
            sessionProperties: this.sessionProperties,
            scopedProperties: this.scopedProperties
        });
        t && (this.uri = t, this.events.emit("display_uri", t));
        const n = await i();
        this.session = n;
        const a = He(n.namespaces);
        return this.namespaces = B(this.namespaces, a), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
    }
    setDefaultChain(e, t) {
        try {
            if (!this.session) return;
            const [i, n] = this.validateChain(e);
            this.getProvider(i).setDefaultChain(n, t);
        } catch (i) {
            if (!/Please call connect/.test(i.message)) throw i;
        }
    }
    async cleanupPendingPairings() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        try {
            this.logger.info("Cleaning up inactive pairings...");
            const t = this.client.pairing.getAll();
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(t)) return;
            for (const i of t)e.deletePairings ? this.client.core.expirer.set(i.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i.topic);
            this.logger.info("Inactive pairings cleared: ".concat(t.length));
        } catch (t) {
            this.logger.warn("Failed to cleanup pending pairings", t);
        }
    }
    abortPairingAttempt() {
        this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
    }
    async checkStorage() {
        this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
    }
    async initialize() {
        this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
    }
    async createClient() {
        var e, t;
        if (this.client = this.providerOpts.client || await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$sign$2d$client$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].init({
            core: this.providerOpts.core,
            logger: this.providerOpts.logger || pe,
            relayUrl: this.providerOpts.relayUrl || We,
            projectId: this.providerOpts.projectId,
            metadata: this.providerOpts.metadata,
            storageOptions: this.providerOpts.storageOptions,
            storage: this.providerOpts.storage,
            name: this.providerOpts.name,
            customStoragePrefix: this.providerOpts.customStoragePrefix,
            telemetryEnabled: this.providerOpts.telemetryEnabled
        }), this.providerOpts.session) try {
            this.session = this.client.session.get(this.providerOpts.session.topic);
        } catch (i) {
            throw this.logger.error("Failed to get session", i), new Error("The provided session: ".concat((t = (e = this.providerOpts) == null ? void 0 : e.session) == null ? void 0 : t.topic, " doesn't exist in the Sign client"));
        }
        else {
            const i = this.client.session.getAll();
            this.session = i[0];
        }
        this.logger.trace("SignClient Initialized");
    }
    createProviders() {
        if (!this.client) throw new Error("Sign Client not initialized");
        if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
        const e = [
            ...new Set(Object.keys(this.session.namespaces).map((t)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(t)))
        ];
        X("client", this.client), X("events", this.events), X("disableProviderPing", this.disableProviderPing), e.forEach((t)=>{
            if (!this.session) return;
            const i = Nt(t, this.session);
            if ((i === null || i === void 0 ? void 0 : i.length) === 0) return;
            const n = Oe(i), a = B(this.namespaces, this.optionalNamespaces), r = ie(G({}, a[t]), {
                accounts: i,
                chains: n
            });
            switch(t){
                case "eip155":
                    this.rpcProviders[t] = new os({
                        namespace: r
                    });
                    break;
                case "algorand":
                    this.rpcProviders[t] = new gs({
                        namespace: r
                    });
                    break;
                case "solana":
                    this.rpcProviders[t] = new ds({
                        namespace: r
                    });
                    break;
                case "cosmos":
                    this.rpcProviders[t] = new fs({
                        namespace: r
                    });
                    break;
                case "polkadot":
                    this.rpcProviders[t] = new ss({
                        namespace: r
                    });
                    break;
                case "cip34":
                    this.rpcProviders[t] = new ys({
                        namespace: r
                    });
                    break;
                case "elrond":
                    this.rpcProviders[t] = new $s({
                        namespace: r
                    });
                    break;
                case "multiversx":
                    this.rpcProviders[t] = new As({
                        namespace: r
                    });
                    break;
                case "near":
                    this.rpcProviders[t] = new Ss({
                        namespace: r
                    });
                    break;
                case "tezos":
                    this.rpcProviders[t] = new Ds({
                        namespace: r
                    });
                    break;
                default:
                    this.rpcProviders[t] = new _s({
                        namespace: r
                    });
            }
        });
    }
    registerEventListeners() {
        if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
        this.client.on("session_ping", (e)=>{
            var t;
            const { topic: i } = e;
            i === ((t = this.session) == null ? void 0 : t.topic) && this.events.emit("session_ping", e);
        }), this.client.on("session_event", (e)=>{
            var t;
            const { params: i, topic: n } = e;
            if (n !== ((t = this.session) == null ? void 0 : t.topic)) return;
            const { event: a } = i;
            if (a.name === "accountsChanged") {
                const r = a.data;
                r && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(r) && this.events.emit("accountsChanged", r.map(Ee));
            } else if (a.name === "chainChanged") {
                const r = i.chainId, c = i.event.data, o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(r), d = Y(r) !== Y(c) ? "".concat(o, ":").concat(Y(c)) : r;
                this.onChainChanged(d);
            } else this.events.emit(a.name, a.data);
            this.events.emit("session_event", e);
        }), this.client.on("session_update", (param)=>{
            let { topic: e, params: t } = param;
            var i, n;
            if (e !== ((i = this.session) == null ? void 0 : i.topic)) return;
            const { namespaces: a } = t, r = (n = this.client) == null ? void 0 : n.session.get(e);
            this.session = ie(G({}, r), {
                namespaces: a
            }), this.onSessionUpdate(), this.events.emit("session_update", {
                topic: e,
                params: t
            });
        }), this.client.on("session_delete", async (e)=>{
            var t;
            e.topic === ((t = this.session) == null ? void 0 : t.topic) && (await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", ie(G({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSdkError"])("USER_DISCONNECTED")), {
                data: e.topic
            })));
        }), this.on(m.DEFAULT_CHAIN_CHANGED, (e)=>{
            this.onChainChanged(e, !0);
        });
    }
    getProvider(e) {
        return this.rpcProviders[e] || this.rpcProviders[ue];
    }
    onSessionUpdate() {
        Object.keys(this.rpcProviders).forEach((e)=>{
            var t;
            this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);
        });
    }
    setNamespaces(e) {
        const { namespaces: t = {}, optionalNamespaces: i = {}, sessionProperties: n, scopedProperties: a } = e;
        this.optionalNamespaces = B(t, i), this.sessionProperties = n, this.scopedProperties = a;
    }
    validateChain(e) {
        const [t, i] = (e === null || e === void 0 ? void 0 : e.split(":")) || [
            "",
            ""
        ];
        if (!this.namespaces || !Object.keys(this.namespaces).length) return [
            t,
            i
        ];
        if (t && !Object.keys(this.namespaces || {}).map((r)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(r)).includes(t)) throw new Error("Namespace '".concat(t, "' is not configured. Please call connect() first with namespace config."));
        if (t && i) return [
            t,
            i
        ];
        const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseNamespaceKey"])(Object.keys(this.namespaces)[0]), a = this.rpcProviders[n].getDefaultChain();
        return [
            n,
            a
        ];
    }
    async requestAccounts() {
        const [e] = this.validateChain();
        return await this.getProvider(e).requestAccounts();
    }
    async onChainChanged(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        if (!this.namespaces) return;
        const [i, n] = this.validateChain(e);
        if (!n) return;
        this.updateNamespaceChain(i, n);
        const a = this.getProvider(i).getDefaultChain();
        t ? (this.events.emit("chainChanged", n), this.emitAccountsChangedOnChainChange({
            namespace: i,
            previousChainId: a,
            newChainId: e
        })) : this.getProvider(i).setDefaultChain(n), await this.persist("namespaces", this.namespaces);
    }
    emitAccountsChangedOnChainChange(param) {
        let { namespace: e, previousChainId: t, newChainId: i } = param;
        var n, a;
        try {
            if (t === i) return;
            const r = (a = (n = this.session) == null ? void 0 : n.namespaces[e]) == null ? void 0 : a.accounts;
            if (!r) return;
            const c = r.filter((o)=>o.includes("".concat(i, ":"))).map(Ee);
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$walletconnect$2f$utils$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidArray"])(c)) return;
            this.events.emit("accountsChanged", c);
        } catch (r) {
            this.logger.warn("Failed to emit accountsChanged on chain change", r);
        }
    }
    updateNamespaceChain(e, t) {
        if (!this.namespaces) return;
        const i = this.namespaces[e] ? e : "".concat(e, ":").concat(t), n = {
            chains: [],
            methods: [],
            events: [],
            defaultChain: t
        };
        this.namespaces[i] ? this.namespaces[i] && (this.namespaces[i].defaultChain = t) : this.namespaces[i] = n;
    }
    onConnect() {
        this.createProviders(), this.events.emit("connect", {
            session: this.session
        });
    }
    async cleanup() {
        this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, this.cleanupPendingPairings({
            deletePairings: !0
        }), await this.cleanupStorage();
    }
    async persist(e, t) {
        var i;
        const n = ((i = this.session) == null ? void 0 : i.topic) || "";
        await this.client.core.storage.setItem("".concat(x, "/").concat(e).concat(n), t);
    }
    async getFromStore(e) {
        var t;
        const i = ((t = this.session) == null ? void 0 : t.topic) || "";
        return await this.client.core.storage.getItem("".concat(x, "/").concat(e).concat(i));
    }
    async deleteFromStore(e) {
        var t;
        const i = ((t = this.session) == null ? void 0 : t.topic) || "";
        await this.client.core.storage.removeItem("".concat(x, "/").concat(e).concat(i));
    }
    async cleanupStorage() {
        var e;
        try {
            if (((e = this.client) == null ? void 0 : e.session.length) > 0) return;
            const t = await this.client.core.storage.getKeys();
            for (const i of t)i.startsWith(x) && await this.client.core.storage.removeItem(i);
        } catch (t) {
            this.logger.warn("Failed to cleanup storage", t);
        }
    }
    constructor(e){
        v(this, "client"), v(this, "namespaces"), v(this, "optionalNamespaces"), v(this, "sessionProperties"), v(this, "scopedProperties"), v(this, "events", new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$events$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]), v(this, "rpcProviders", {}), v(this, "session"), v(this, "providerOpts"), v(this, "logger"), v(this, "uri"), v(this, "disableProviderPing", !1), this.providerOpts = e, this.logger = typeof (e === null || e === void 0 ? void 0 : e.logger) < "u" && typeof (e === null || e === void 0 ? void 0 : e.logger) != "string" ? e.logger : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pino$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__pino$3e$__["pino"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$walletconnect$2f$logger$2f$dist$2f$index$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getDefaultLoggerOptions"])({
            level: (e === null || e === void 0 ? void 0 : e.logger) || pe
        })), this.disableProviderPing = (e === null || e === void 0 ? void 0 : e.disableProviderPing) || !1;
    }
}
const Bs = J;
;
 //# sourceMappingURL=index.es.js.map
}),
}]);

//# sourceMappingURL=node_modules_8ce0a9cb._.js.map